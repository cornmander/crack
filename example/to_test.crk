// Copyright 2009 Google Inc.

# overriden definitions in the same context should be an error
int32 a;
int32 a;

# overridden definitions should issue a warning
int32 x;
if (1) { int32 x; }

# duplicate function names in the same context should issue an error
void func() {}
void func() {}

# duplicate function names in different contexts should issue a warning
void func() {
    void func() {}
}

# assignment to a function argument should be legal.
void func(int32 a) {
    a = 100;
}

# void variable definitions should error
void a;

# does this really make any sense?  It's currently legal.
void returnsVoid() {}
void returnsOther() { return returnsVoid(); }


# these are tests that I've done at some point with interesting results and 
# should be added to the general test suite

# Tests that local vars in a loop (LLVM allocas) do not overrun the stack.
# Blocks in a function caused problems because of the order of deletion of 
# ref-counted pointers.
void foo() {
    while (1) {
        byteptr str = 'test';
        puts(str);
    }
}
foo();

void global() { }
class Foo {
    void f() { this.global(); }  // should error
};

# currently fails because we generate unreachable code after the else but 
# don't give it a return statement.  Need to stop generating unreachable code.
int32 foo(int32 x) { if (x) return 1; else return 0; puts("test"); }

# this snippet will currently print "true" instead of 100, because implicit 
# conversion means f(bool) hides f(int32).  The overloader should reorder the 
# methods so the least general is called first.  I'm not sure what it should 
# do for f(bool, int32) vs f(int32, bool).  It should probably not do
# reordering and just not attempt conversions unless exact matches fail.
void f(int32 v) {printint(v);}
void f(bool b) {if (b) puts("true"); else puts("false")}
f(100);

# this currently doesn't work because 'A' gets treated like a definition
class A { };
A();

# should not be able to derive a class from an incomplete class
class A {
    class B : A {}
};

# this breaks (not sure what we're doing in the parser)
class Foo {} print('test');

# assignment to functions
void f() {}
f = 100;

# this should cause an error because x is initialized before y and we are 
# initializing x with the value of y.
class A {
    int x;
    int y;
    oper init() : y = 0, x = y {}
};

# not sure why, but this causes a "Calling a function with a bad signature" 
# assertion failure in LLVM:
import crack.lang FreeBase;
class Foo : FreeBase { oper bind() { print('binding'); } oper release() { print('releasing'); } };
f := array[Foo](10);
Foo foo;
f[0] = Foo();

# the implicit "del" operator does not override correctly
class Marker { oper release() { puts('releasing Marker'); } }
class A : VTableBase {}
class B : A {
    Marker m;
}
A a = B();
a.__del();

# this should fail but does not.
class A : VTableBase {}
class B : A {}
A a;
(B.cast(a)); # should die here.
puts('fail');
