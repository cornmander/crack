## Regular expressions (based on PCRE)

import crack.lang Buffer, die, free, SubString;
import crack.io cerr, StringFormatter;
import crack.exp.bindings ByteptrWrapper, Opaque;

import crack.ext._pcre pcre_compile2, pcre_exec, pcre_fullinfo, 
                       pcre_get_stringnumber, PCRE;


int _PCRE_INFO_CAPTURECOUNT = 2;

# keep one of these around in case we want to format a death string.
death := StringFormatter();

## regex base class that we can store in a Match object.
class _RegexBase {
    PCRE _rx;
    
    oper init(PCRE rx0) : _rx = rx0 {}
};

## A regular expression match.
class Match {
    String subject;
    _RegexBase regex;
    array[int] __captures;
    uint __captureCount;
    
    oper init(_RegexBase regex0, String subject0, array[int] captures, 
              uint captureCount
              ) : 
        regex = regex0,
        subject = subject0,
        __captures = captures,
        __captureCount = captureCount {
    }
    
    oper del() {
        free(__captures);
    }

    void __checkGroupIndex(uint index) {
        if (index >= __captureCount) {
            death 
                `match out of bounds (index = $index, max = $__captureCount)`;
            die(death.createString());
        }
    }
    
    ## Returns the match group by index.  Groups are indexed from left to 
    ## right by the position of the starting parenthesis.  Group 0 is the 
    ## entire expression.
    String group(uint index) {
        __checkGroupIndex(index);
        
        i := index * 2;
        start := __captures[i];
        end := __captures[i + 1];
        return SubString(subject, uint(start), uint(end - start));
    }
    
    String group() { return group(0); }

    uint __getIndex(String name) {
        int i = pcre_get_stringnumber(regex._rx, name.buffer);
        if (i < 0) {
            death `undefined group name $name`;
            die(death.createString());
        }
        return uint(i);
    }

    ## Returns the index of the beginning of the indexed group.
    uint begin(uint index) {
        __checkGroupIndex(index);
        return uint(__captures[index * 2]);
    }
    
    ## Returns the index of the beginning of the named group.
    uint begin(String name) {
        return begin(__getIndex(name));
    }
    
    uint begin() { return begin(0); }
    
    ## Returns the index of the end of the indexed group.
    uint end(uint index) {
        __checkGroupIndex(index);
        return uint(__captures[index * 2 + 1]);
    }
    
    uint end(String name) {
        return end(__getIndex(name));
    }
    
    uint end() { return end(0); }

    ## Returns the value of the named group.    
    String group(String name) {
        i := __getIndex(name);
        return group(i);
    }
};

## A compiled regular expression.
class Regex : _RegexBase {
    
    # the number of sub-expressions to capture.
    uint __captureCount;
    
    ## Compile a regular expression from 'pattern'.  The regex library uses 
    ## PCRE, see the 'pcresyntax' man page for regular expression syntax.
    oper init(String pattern) : _RegexBase(null) {
        array[int] intReturns = {2};
        array[byteptr] errorText = {1};
        _rx = pcre_compile2(pattern.buffer, 0, intReturns, errorText,
                            intReturns + 1,
                            null
                            );
        if (_rx is null) {
            # error compiling the regex.
            f := StringFormatter();
            f `Error compiling regular expression: $(errorText[0])`;
            free(errorText);
            free(intReturns);
            die(f.createString());
        }
        free(errorText);
        
        # figure out how many capturing sub-patterns there are
        pcre_fullinfo(_rx, null, _PCRE_INFO_CAPTURECOUNT, intReturns);
        __captureCount = uint(intReturns[0]) + 1;
        free(intReturns);
    }
    
    ## Search 'subject' for the regular expression.  Returns a Match 
    ## object if it is found or null if not.
    Match search(String subject) {
        captures := array[int](__captureCount * 3);
        Match result;
        rc := pcre_exec(_rx, null, subject.buffer, subject.size, 0, 0, 
                        captures,
                        __captureCount * 3
                        );
        if (rc >= 0) {
            return Match(this, subject, captures, __captureCount);
        } else {
            free(captures);
            return null;
        }
    }
    
    oper del() { free(_rx); }
};


