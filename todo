
Crack ToDo File & Project Plan
==============================

Copyright 2009 Google Inc.

Unassigned
----------

-   decide what to do about operater overloads within classes.

Roadmap
-------

for 0.1:
-   the "oper" keyword
    -   general implementation DONE
    -   oper init initializers, oper del cleanups
        -   preserve order of definition during member initialization and 
            destruction
    -   need syntax to allow calling "oper" functions from an expression, need 
        to get rid of the __del() hack.
-   short circuit logic operators
-   floating point types
-   Should be able to do instance construction in a statement context without 
    it being misinterpreted as a definition
-   fix numeric conversion.
-   string interpolation expressions: s := `some string $val`;
-   type casting.
-   need to define comparison operators for Object in crack.lang and make them 
    part of the standard imports.
-   fix instance variable default initialization: 
    class A { B b; oper init() {} } doesn't construct 'b'.

Completed for 0.1:
-   global variables should not get cleaned up until the end of the program.
    DONE.
-   fix cleanups during assignment (a = b does b.bind() but not a.release())
    DONE
-   composition of constructors/destructors DONE
-   allow utf-8 chars for strings and identifiers.  DONE
-   the '`' operator DONE
-   multiple inheritence shouldn't cause bad errors (it need not work) DONE 
    (it now works).
-   fix overload bug DONE
-   numeric negation: "int j = -i;" DONE
-   "Foo x = {1, 2}" construction syntax. DONE
-   break & continue DONE
-   explicit base class method invocation syntax (void foo() {Super.foo();}) 
    DONE
-   empty statements should work: if (false) ; DONE
-   get rid of the semicolon after class definitions DONE

for 1.0:
-   cleanup:
    -   combine FuncDef and OverloadDef into a base class with a virtual 
        matches() for arg list defs, or just make FuncDef a smaller thing and 
        always use OverloadDef
    -   allowing turning off code generation by replacing the builder with a 
        "NullBuilder"  NullResultExpr follows:
            class NullResultExpr : public ResultExpr {
                public:
                    // won't work, need a non-null ResultExpr value
                    NullResultExpr() : ResultExpr(0) {} 
                    
                    ResultExprPtr emit(Context &context) {
                        return this;
                    }
            };
    
        
-   function arguments are currently SSA values, which means this won't work:
    type func(int a) { a = 100; }
-   doc-comments
-   first class functions (including overload selection: func[Type1, Type2])
-   keyword arguments
-   sequence construction 
-   type inference
-   for/in loops
-   exceptions
-   minor features
    -   warn the user when an overload hides an earlier overload (foo(String) 
        following foo(Object), for example).


