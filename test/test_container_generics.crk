# Copyright 2010 Google Inc.

import crack.lang cmp, die, free;
import crack.runtime random;
import crack.io cout, Formatter, FStr, StringFormatter;
import crack.cont.array Array;
import crack.cont.treemap TreeMap;
import crack.cont.list List, DList;
import crack.cont.hashmap HashMap;
import crack.exp.algorithm QuickSort;
@import crack.exp.ann define;

TreeMap[String, int] m = {};
m['first'] = 100;
m['second'] = 200;
m['third'] = 300;
m['fourth'] = 400;
if (m['first'] != 100 || m['second'] != 200)
    cout `failed TreeMap access\n`;

Array[String] sa = {};

for (item :in m) {
    StringFormatter fmt = {};
    fmt `$(item.key): $(item.val)`;
    sa.append(fmt.createString());
}

QuickSort[String] qs = {sa};

# Now sa = [first: 100, fourth: 400, second: 200, third: 300]

if (sa[0] != 'first: 100' || sa[1] != 'fourth: 400')
    cout `string array or iteration failed\n`;

#  test subarray
sub := sa.subarray(1);
if (sub[1] != 'second: 200' || sub[2] != 'third: 300' || sub[0] != 'fourth: 400')
    cout `string array subarray  1 failed, got '$sub'\n`;

if (sub.count() != 3) 
   cout `string array subarray failed, length $(sub.count()) != 3\n`;

# 2 arguments: start, len
sub = sa.subarray(1, 1);
if (sub[0] != 'fourth: 400')
    cout `string array subarray 2 failed, got '$sub'\n`;

if (sub.count() != 1) 
   cout `string array subarray failed, length $(sub.count()) != 1\n`;

sub = sa.subarray(1);
if (sub[1] != 'second: 200' || sub[2] != 'third: 300' || sub[0] != 'fourth: 400')
    cout `string array subarray 3 failed, got '$sub'\n`;

# array slice
sub = sa.slice(1, 3);
if (sub.count() != 2) 
   cout `string array subarray failed, length $(sub.count()) != 3\n`;

if (sub[1] != 'second: 200' || sub[0] != 'fourth: 400')
    cout `string array slice 1 failed, got '$sub)'\n`;

sub = sa.slice(1, 2);
if (sub.count() != 1) 
   cout `string array slice failed, length $(sub.count()) != 2\n`;

if (sub[0] != 'fourth: 400')
    cout `string array slice 2 failed, got '$sub'\n`;



testA :=Array[String]!['bogus', 'test', 'array'];
if (testA[0] != 'bogus' || testA[1] != 'test' || testA[2] != 'array')
   cout `string array ! notation failed, got $testA\n`;

intA := Array[int]![1,2,3,4,5,6,7,8,9,0];
stringA := Array[String]!["bogus", "test", "string"];

intRepr:=FStr() `$intA`;
stringRepr:=FStr() `$stringA`;

if (intRepr != '[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]')
    cout `Array[int].writeTo failed\n`;
if (stringRepr != '[bogus, test, string]')
    cout `Array[String].writeTo failed\n`;


# test a second invocation (uses a different code path)
class Foo {}
Array[Foo];

@define concat(Type) {
    String concat(Type list) {
        StringFormatter result = {};
        for (x :in list)
            result `$x`;
        return result.createString();
    }
}

@concat(List[String]);

List[String] s = {};
s.append('1');
s.append('2');
if (concat(s) != '12' || s.count() != 2)
    cout `Failed List appends\n`;
s = List[String]();
s.pushHead('2');
s.pushHead('1');
if (concat(s) != '12' || s.count() != 2)
    cout `failed List pushHeads\n`;

s.popHead();
if (concat(s) != '2' || s.count() != 1)
    cout `failed List popHead\n`;
s.popHead();
if (concat(s) != '' || s.count() != 0)
    cout `failed List popHead on empty list\n`;
s = List[String]();
s.insert(0, 'first');
s.insert(1, 'last');
s.insert(1, 'middle');
if (concat(s) != 'firstmiddlelast' || s.count() != 3)
    cout `failed List inserts\n`;
s.delete(0);
if (concat(s) != 'middlelast' || s.count() != 2)
    cout `failed List delete of first elem\n`;
s.pushHead('first');
s.delete(1);
if (concat(s) != 'firstlast' || s.count() != 2)
    cout `failed List delete of middle elem\n`;
s.delete(1);
if (concat(s) != 'first' || s.count() != 1)
    cout `failed List delete of last elem\n`;

if (s[0] != 'first')
    cout `failed List [] access\n`;

@concat(DList[String]);

void checkDList(DList[String] list, String val, uint count, String message) {
    # make sure that the list is properly terminated
    revIter := list.iter(true);
    if (revIter.next())
        cout `$message: last element has non-null next\n`;

    # verify that the list looks the same forwards as backwards
    List[String] temp = {};
    for (revIter = list.iter(true); revIter; revIter.last())
        temp.pushHead(revIter.elem());
    
    iter := list.iter();
    listIter := temp.iter();
    i := 0;
    while (iter && listIter) {
        
        if (iter.elem() != listIter.elem())
            cout `$message: reverse failure in node -$i, expected \
$(listIter.elem()), got $(iter.elem())\n`;
        
        ++i;
        listIter.next();
        iter.next();
    }
    
    # make sure the contents of the list from front to back are what we expect
    flat := concat(list);
    if (flat != val)
        cout `$message: incorrect contents, expected $val, got $flat\n`;
    if (count != list.count())
        cout `$message: incorrect count, expected $count, got \
$(list.count())\n`;
}

DList[String] dl = {};

dl.append('1');
dl.append('2');
checkDList(dl, '12', 2, 'Failed DList appends');

dl = DList[String]();
dl.pushHead('2');
dl.pushHead('1');
checkDList(dl, '12', 2, 'Failed DList pushHeads');

dl.popHead();
checkDList(dl, '2', 1, 'Failed DList popHead');
dl.popHead();
checkDList(dl, '', 0, 'Failed DList popHead on empty list');

dl = DList[String]();
dl.insert(0, 'first');
dl.insert(1, 'last');
dl.insert(1, 'middle');
checkDList(dl, 'firstmiddlelast', 3, 'failed DList inserts');

dl.delete(0);
checkDList(dl, 'middlelast', 2, 'failed DList delete of first elem');

dl.pushHead('first');
dl.delete(1);
checkDList(dl, 'firstlast', 2, 'failed DList delete of middle elem');
dl.delete(1);
checkDList(dl, 'first', 1, 'failed DList delete of last elem');
dl.delete(0);
checkDList(dl, '', 0, 'failed DList delete of only elem');

dl.append('elem');
checkDList(dl, 'elem', 1, 'failed DList append after deleting');
if (dl[0] != 'elem')
    cout `failed DList [] access\n`;

dl.append('elem2');
dl.popTail();
checkDList(dl, 'elem', 1, 'failed DList append after popTail');
dl.popTail();
checkDList(dl, '', 0, 'failed DList append after popTail of last elem');

dl = DList[String]();
dl.append('1');
dl.append('2');
iter := dl.iter();
dl.insert(iter, '0');
iter.next(); iter.next();
dl.insert(iter, '1.5');
checkDList(dl, '011.52', 4, 'failed DList iterator insert');
dl.delete(iter);
iter = dl.iter();
dl.delete(iter);
checkDList(dl, '12', 2, 'Failed DList iterator delete');
dl.delete(iter);
dl.delete(iter);
checkDList(dl, '', 0, 'Failed DList iterator delete of last elements');

hm := HashMap[String, int]();
for (int i = 0; i < 100; ++i) {
    key := FStr() `$i`;
    hm[key] = i;
}

for (int i = 0; i < 100; ++i) {
    key := FStr() `$i`;
    if (hm[key] != i)
        cout `FAILED hash key lookup for $key\n`;
    hm.delete(key);
}

if (hm.count() != 0)
    cout `FAILED hash key count after deletes\n`;

# fuzz test hash map
if (true) {
    HashMap[int, int] map = {};
    Array[int] a = {};
    int i;
    while (i < 10000) {
        action := random() % 3;
        if (action < 2) {
            # insert a new random value
            
            # find an unused key
            v := random();
            while (map.get(v))
                v = random();
    
#            cout `$i: adding $v\n`;
            map[v] = v;
            a.append(v);
        } else if (action == 2 && a.count()) {
            # delete key
            index := uint(random()) % a.count();
#            cout `$i: deleting a[$index]: $(a[index])\n`;
            map.delete(a[index]);
            a.delete(index);
        }

        map.checkConstraints();
        ++i;
        
        # iterate over the map
        int countedElems;
        for (x :in map)
            ++countedElems;
        if (countedElems != map.count())
            cout `FAILED counted a different number of elements in a map than\
expected\n`;
    }
}

cout `ok\n`;
