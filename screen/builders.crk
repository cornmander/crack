// Builder definitions for screen
// Copyright 2010-2011 Shannon Weyrick <weyrick@mozek.us>

import crack.io Writer, StringWriter, StringFormatter, FStr;
import crack.exp.dir Directory;
import crack.exp.file File, FileInfo;
import crack.exp.process Process;
import crack.cont.treemap TreeMap;
import crack.cont.array Array;
import crack.lang AssertionError;

import config config, T_INIT, T_CRACK, T_BINARY, T_FINISHED;
import testdata TestData;

///////////////////////////

class Result {
    bool pass;
    String expected, actual;

    oper init(bool t): pass = t { }
    oper init(String e, String a): pass = false, expected = e, actual = a { 
        
    }
}

class BuilderTestHarness;

// one per builder that exists in crack
// specific builders are defined below BuilderTestHarness
class CrackBuilderDef {
    BuilderTestHarness newTestHarness(TestData d) {
        throw AssertionError("virtual");
    }
    bool separateBinary() { throw AssertionError("virtual"); }
    String getName() { throw AssertionError("virtual"); }
    String getNick() { throw AssertionError("virtual"); }
    String getCrackOptions(BuilderTestHarness h) { return ""; }
    String getBinaryOptions(BuilderTestHarness h) { return ""; }
}


// execute crack process for specific builder for specific test
// get output, compare results, decide pass/fail
// diff failed output
// maintain state so we don't have on crack processes
// maintain final PASS/FAIL output for this builder/test
class BuilderTestHarness {

    Result _crackResult;
    Result _binaryResult;

    int _status = T_INIT;
    StringWriter _output = { }; // test results
    StringWriter _vOutput = { }; // verbose
    CrackBuilderDef _bDef;
    TestData _data;
    Process _proc;
    String _testBinary;

    oper init(CrackBuilderDef d, TestData data) : _bDef = d,
                                                  _data = data { }


    String _colorMsg(String c, String msg) {
        sw := StringFormatter(128);
        sw `\033[$(c);1m$(msg)\033[0m`;
        return sw.createString();
    }
    void _pass() {
        _output.write(_colorMsg("32", "PASS "));
    }
    void _fail() {
        _output.write(_colorMsg("31", "FAIL "));
    }

    Result compareOutput(String expected, String actual) {

        if (expected == actual) {
            _pass();
            return Result(true);
        }
        else {
            _fail();
            return Result(expected, actual);
        }

    }

    void runBinary() {

        String args = {};

        if (_data.sections["ARGS"]) {
            args = _data.sections["ARGS"].rtrim();
        }

        _output.write(_bDef.getNick());
        _output.write(" Run: ");

        // native: run binary to get final results for comparison
        bfi := FileInfo(_testBinary);
        if (!bfi.exists()) {
            _fail();
            _vOutput.write("binary wasn't created, check compile output");
            _binaryResult = Result(false);
            _status = T_FINISHED;
            return;
        }
        // XXX binary args (script argv)
        if (config.verbose) {
            _vOutput.write(_testBinary);
            _vOutput.write("\n");
        }
        _status = T_BINARY;
        _proc = Process(_testBinary);

    }

    void finishBinary() {

        if (_proc.failed()) {
            _fail();
            _output.write("binary failed to run\n");
        }
        else {
            nativeOut := _proc.getStdOut();
            nativeErr := _proc.getStdErr();
            expect := _data.sections["EXPECT"];
            _binaryResult = compareOutput(expect, nativeOut);
            // XXX err output EXPECTERR ?
        }

        _proc.close();


    }

    void run() {

        if (_bDef.separateBinary()) {
            _testBinary = config.outDir.nameWithTrailing()+
                           _data.fInfo.basename(true);
        }

        StringWriter args = {};

        if (_data.sections["ARGS"]) {
            args.write(_data.sections["ARGS"].rtrim());
        }

        if (_data.dirConfig) {
            args.write(" ");
            args.write(_data.dirConfig.options);
        }

        args.write(_bDef.getCrackOptions(this));

        // XXX template argv section
        cmd := config.crackBin+" -B "+_bDef.getName()+" "+args.createString()+" "+_data.scriptName;
        if (config.libPath)
            cmd = cmd + " -l " + config.libPath;
        if (config.verbose) {
            _vOutput.write(cmd);
            _vOutput.write("\n");
        }

        _output.write(_bDef.getNick());
        _output.write(": ");

        // XXX stdin
        _status = T_CRACK;
        _proc = Process(cmd);

    }

     void finishCrack() {

        compileOut := _proc.getStdOut();
        compileErr := _proc.getStdErr();

        if (_bDef.separateBinary()) {
            // if return code is not 0, we'll be checking against error
            // output
            // XXX
            _crackResult = Result(true);
            _pass();
            return;
            
/*
         && _proc.getReturnCode() != 0) {
            // compile failed
            _fail();
            _vOutput.write(" Return code: ");
            _vOutput.write(FStr() `$(_proc.getReturnCode())`);
            _vOutput.write("\n");
            _crackResult = Result(false);
            return;
            */
        }

        _proc.close();

        if (!_data.sections["EXPECT"]) {
           _vOutput.write("no valid EXPECT section\n");
           _crackResult = Result(false);
           return;
        }

        expect := _data.sections["EXPECT"];
        _crackResult = compareOutput(expect, compileOut);

    }


    int tick() {

        if (_status == T_FINISHED)
            return _status;

        if (_proc.isRunning())
            return _status;

        // we're in state CRACK or BINARY, and our process is done
        if (_status == T_CRACK) {
            finishCrack();
            // if we have a separate binary, launch it
            if (_bDef.separateBinary())
                runBinary();
            else
                _status = T_FINISHED;
        }
        else if (_status == T_BINARY) {
            finishBinary();
            _status = T_FINISHED;
        }

        if (_status == T_FINISHED && _vOutput.size)
            _vOutput.write("\n");

        return _status;
    }

}

class JitTestHarness : BuilderTestHarness {

    oper init(CrackBuilderDef d, TestData data): BuilderTestHarness(d, data) { }

}

class NativeTestHarness : BuilderTestHarness {

    oper init(CrackBuilderDef d, TestData data): BuilderTestHarness(d, data) { }

}

//////////////////////////////

class JitBuilderDef : CrackBuilderDef {
    BuilderTestHarness newTestHarness(TestData d) {
        return JitTestHarness(this, d);
    }
    bool separateBinary() { return false; }
    String getName() { return "llvm-jit"; }
    String getNick() { return "JIT"; }
}

class NativeBuilderDef : CrackBuilderDef {
    BuilderTestHarness newTestHarness(TestData d) {
        return NativeTestHarness(this, d);
    }
    bool separateBinary() { return true; }
    String getName() { return "llvm-native"; }
    String getNick() { return "AOT"; }
    String getCrackOptions(BuilderTestHarness h) {
        return " -b out="+h._testBinary;
    }
}

// These are the list of builders we support in the test suite.
// The keys to this hash are used to specify which builders to run
// from the command line
TreeMap[String, CrackBuilderDef] builderDefList = { };
builderDefList["jit"] = JitBuilderDef();
builderDefList["native"] = NativeBuilderDef();
