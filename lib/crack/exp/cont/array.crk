# Copyright 2010 Google Inc
# Generic array implementation
# to use this macro, you must:
#   import crack.lang die, free;
#   @import crack.exp.cont.array GenericArray, GenericObjArray, 
#           GenericPrimArray;
# You must import GenericArray and the specific macro for your needs 
# (GenericObjArray for objects with oper bind and release, GenericPrimArray 
# for primitive types).

@import crack.ann define, export, exporter;
@exporter;

@define GenericArray(Name, Elem, binder, releaser) {

    ## An Array is a sequence backed by a low-level array.  It supports the 
    ## bracket operators and adding items at the end.
    class Name {
        
        array[Elem] __rep = null;
        uint __cap, __size;

        @final
        void oper []=(uint index, Elem elem) {
            if (index > __size)
                die('Index out of range in Array.oper []=');
            
            tmp := __rep[index];
            __rep[index] = elem;
            binder;
            elem = tmp;
            releaser;
        }

        @final
        void oper []=(int index, Elem elem) {
            uint i;
            if (index < 0)
                i = __size + uint(index);
            else
                i = uint(index);
            
            this[i] = elem;
        }

        @final
        uint count() {
            return __size;
        }

        @final
        Elem oper [](uint index) {
            if (index > __size)
                die('Index out of range in Array.oper []');
            
            return __rep[index];
        }

        @final
        Elem oper [](int index) {
            uint i;
            if (index < 0)
                i = __size + uint(index);
            else
                i = uint(index);
            
            return this[i];
        }

        @final
        Elem last() { return __rep[__size - 1]; }

        class ArrayIter {
            Name __arr;
            uint __index;
            bool __first = true;
        
            oper init(Name arr) : __arr = arr {}
            

            Elem elem() {
                return __arr[__index];
            }

            @final
            bool next() {
                cnt := __arr.count();
                if (__index < cnt) {
                    __index = __index + 1;
                    return __index < cnt;
                } else {
                    return false;
                }
            }

            @final
            bool nx() {
                if (__first) {
                    __first = false;
                    return __index < __arr.count();
                } else {
                    return next();
                }
            }
            
            bool isTrue() {
                return __index < __arr.count();
            }
        }
        
        oper init(uint initCapacity) :
            __rep = array[Elem](initCapacity), 
            __cap = initCapacity,
            __size = 0 {
        }
        
        oper init() : 
            __rep = array[Elem](16), 
            __cap = 16,
            __size = 0 {
        }
        
        oper del() {
            uint i;
            while (i < __size) {
                elem := __rep[i];
                releaser;
                i = i + 1;
            }
            free(__rep);
        }
        
        void realloc(uint newCapacity) {
            if (newCapacity < __cap)
                die('Array.realloc() - decreasing capacity');
                
            newRep := array[Elem](newCapacity);
            
            # move all of the entries to the new array.
            uint i;
            while (i < __size) {
                newRep[i] = __rep[i];
                i = i + 1;
            }
    
            free(__rep);
            __rep = newRep;
            __cap = newCapacity;
        }

        @final
        void append(Elem elem) {
            if (__size == __cap)
                realloc(__cap * 2);
            
            __rep[__size] = elem;
            binder;
            __size = __size + 1;
        }

        Elem pop() {
           if (__size>0)
              return __rep[--__size];
           else
              return null;
        }

      @final
        ArrayIter iter() {
            return ArrayIter(this);
        }
        
        uint capacity() {
            return __cap;
        }

        Name rest(uint i){
            result := Name(__size - i);
            for (j := i; j < __size; j++)
            result.append(__rep[j]);
            return result;
        }

        Name _merge(Name left, Name right){
            result := Name(left.count()*2);
            while (left.count() > 0 || right.count() > 0){
            if (left.count() > 0 && right.count() > 0){
                if (left[0] <= right[0]){
                    result.append(left[0]);
                    left = left.rest(1);
                }
                else{
                    result.append(right[0]);
                    right = right.rest(1);
                }
            }
            else if (left.count() > 0){
                    result.append(left[0]);
                    left = left.rest(1);
                }
            else if (right.count() > 0){
                    result.append(right[0]);
                    right = right.rest(1);
                }
            }
            return result
        }

        Name _merge_sort(Name m, uint depth){
            if (m.count() <= 1) return m;

            middle := m.count() / 2;
            left := Name(middle);
            right := Name(middle);
            result := Name(middle * 2);
            if (depth>10) return result;

            for (x:=0; x < middle; x++) left.append(m[x]);

            for (x:=middle; x < m.count(); x++) right.append(m[x]);

            left = _merge_sort(left, depth+1);
            right = _merge_sort(right, depth+1);
            result = _merge(left, right);
            return result;
        }

        Name sort(){
            return _merge_sort(this, 0);
        }

        ## delete the element at 'index'.
        void delete(uint index) {
            if (index > __size)
                die('Index out of range in Array.delete()');
            
            # release the object at the index
            elem := __rep[index];
            releaser;
            
            # move everything else down one
            uint i = index;
            while (i < __size - 1) {
                __rep[i] = __rep[i + 1];
                ++i;
            }
    #        memmove(__rep + index, __rep + index + 1, __size - index);
            --__size;
        }   
    }
} # @define GenericArray

@export GenericArray

@define GenericObjArray(Name, Type) { 
    @GenericArray(Name, Type, elem.oper bind(), elem.oper release())
}

@export GenericObjArray

@define GenericPrimArray(Name, Type) {
    @GenericArray(Name, Type, ;, ;)
}

@export GenericPrimArray

