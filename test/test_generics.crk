# Copyright 2011 Google Inc.

import test.testmod_generic G;


void someFunc() {}

class FakeFormatter {
    int result;
    void format(byteptr val) {
        result |= val[0];
    }
    void format(int val) {
        result |= val;
    }
    void format(float val) { }
    
    int leave() { return result; }
    
    oper to bool() { return 1; }
}

bool gotStaticCalled;
class A[T] {
    T val;

    oper init(T val) : val = val {}
    @static void gotStatic() { gotStaticCalled = 1; }
    
    int format() { return FakeFormatter() `\001$val\002`; }
    
}

if (A[int](100).val != 100) puts('FAILED generic based on int');
if (A[float](1.0).val != 1.0) puts('FAILED generic based on float');
if (G[int]().getVal() != 100) puts('FAILED imported generics');

A[int].gotStatic();
if (!gotStaticCalled) puts('FAILED static function call');

if (A[int](4).format() != 7) puts('FAILED generic with i-string');


class B[T1, T2] { T1 f(T1 a) { return a; } T2 f(T2 a) { return a; } }
B[int, float] b = {};
if (b.f(100) != 100 || b.f(1.5) != 1.5)
    puts('FAILED two argument generic');

class C { 
    oper to int() { return 1; } // so we can match a formtter

    A[C] wrap; 
    oper init() : wrap(this) {}
}
C c = {};
if (!(c.wrap.val is c))
    puts('FAILED nested generic parameterized by outer class');

# test parsing a generic derived from another generic parameterized by a 
# generic parameter
class D[T] : A[T] { oper init(int val) : A[T](val) {} }

if (D[int](100).val != 100)
    puts('FAILED generics inhereting from other generics');

# verify that symbols from enclosing contexts are available to a generic
if (1) {
    gotStaticCalled = 0;
    void e() {}

    void outer() {
        void f() {}
        int i;
        class B[X] {
            @static void g() { f(); e(); gotStaticCalled = 1; }
        }
        
        void h() {
            B[int].g();
        }
        
        h();
    }
    
    outer();
    if (!gotStaticCalled)
        puts('FAILED generics accessing symbols from enclosing contexts');
}

puts('ok');
