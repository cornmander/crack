// A test suite for crack
// Copyright 2010-2011 Shannon Weyrick <weyrick@mozek.us>

import crack.io cout, cerr, Formatter, Writer, StringWriter, StringFormatter, FStr;
import crack.sys argv, exit;
import crack.exp.dir Directory;
import crack.exp.file File, FileInfo;
import crack.exp.regex Regex;
import crack.exp.process Process;
import crack.exp.cmdline CmdOptions, Option, CMD_STR, CMD_INT, CMD_BOOL;
import crack.cont.hashmap HashMap;
import crack.cont.array Array;
import crack.cont.priorityqueue PriorityQueue;
import crack.strutil StringArray, split;

import testdata TestData, DirConfig;
import builders BuilderTestHarness, CrackBuilderDef, builderDefList, Result;
import config config, T_INIT, T_RUNNING, T_FINISHED;

class Template {

     @static
     HashMap[String, String] load(String fileName) {

        HashMap[String, String] sections = {};

        f := File(fileName, "r");
        if (!f.isValid()) {
            cout `file: $(fileName) could not be opened!\n`;
            return null;
        }

        // parse out sections
        String lineBuf, curSection;
        StringWriter dataBuf = {};
        headerPat := Regex('^%%(\\w+)%%$');
        while (lineBuf = f.nextLine()) {
            // look for section change
            m := headerPat.search(lineBuf);
            if (m) {
                if (curSection)
                    sections[curSection] = dataBuf.createString();
                curSection = m.group(1);
                //cerr `debug: switching to group $curSection\n`;
                dataBuf = StringWriter();
            }
            else {
                // add line to current section
                dataBuf.write(lineBuf);
            }
        }
        if (curSection)
            sections[curSection] = dataBuf.createString();

        return sections;

    }

}

// represent single test template
// parse template, store data fields, write script
// maintain state while running available builders so we
//     don't hang on any one builder
// maintain final concatenated output of all builders run on this test
// a test is finished when all of the configured builders have run
class Test {

    TestData _data = {};
    StringWriter _output = {};
    StringWriter _vOutput = {};

    int _status = T_INIT;
    Array[BuilderTestHarness] _harness = {};
    int _activeHarness = 0;

    bool pass = false;

    String _isSkipped;

    // for the benefit of the priority queue, by default we give higher priority to tests
    // based on comparing the file name. thus, 0_foo is higher priority than 1_foo
    // note this is not strictly the same as sorting them by name, because of the
    // properties of the heap structure.
    int cmp(Object other) {
        if (other.isa(Test)) {
            return -(_data.fInfo.name.cmp(Test.unsafeCast(other)._data.fInfo.name));
        }
        else {
            return 0;
        }
    }

    // ensure test has required sections and that they contain valid data
    // also check to see if we're skipping this test for some reason
    void checkTemplate() {        
        if (!_data.sections.contains("FILE")) {
            _isSkipped = "the template was missing a FILE section";
        }
        if (!_data.sections.contains("EXPECT")) {
            _isSkipped = "the template was missing a EXPECT section";
        }
        if (_data.sections.contains("TEST"))
            _data.desc = _data.sections["TEST"].rtrim();
    }

    void writeScript() {
        
        _data.scriptName = config.outDir.nameWithTrailing()+
                           _data.fInfo.basename(true) + ".crk";
        out := File(_data.scriptName,"w");
        out.write(_data.sections["FILE"]);
        
    }

    void run() {
        
        if (_isSkipped) {
            cout `[$(_data.fInfo)]: $_isSkipped\n`;
            _status = T_FINISHED;
            return;
        }
        
        writeScript();

        _status = T_RUNNING;

        // start initial harness
        _activeHarness = 0;
        _harness[_activeHarness].run();

    }

    void checkResult(Result r) {
        if (!r)
            return;
        if (!r.pass &&
            (config.showDiff || config.stopOnFail) &&
            r.expected.size) {
            _output.write(FStr() `\n---- Diff ----\nExpected: [$(r.expected)]`);
            _output.write(FStr() `\nActual: [$(r.actual)]\n--------------\n`);
        }
    }
/*

    XXX merely defining this function causes a strange overload bug to appear

    bool _allBuildersPass() {
        for (b :in _harness) {
            if ((b.crackResult && !b.crackResult.pass) ||
                (b.binaryResult && !b.binaryResult.pass))
                return false;
        }
        return true;
    }
*/

    int tick() {

        // poll the builder process
        // if finished, get/show output, increment activeBuilder
        if (_harness[_activeHarness].tick() == T_FINISHED) {

            if (config.verbose)
                _vOutput.write(_harness[_activeHarness].vOutput.createString());
            _output.write(_harness[_activeHarness].output.createString());

            checkResult(_harness[_activeHarness].crackResult);
            checkResult(_harness[_activeHarness].binaryResult);

            _activeHarness++;
            if (_activeHarness < _harness.count()) {
                _harness[_activeHarness].run();
            }
            else {
                _status = T_FINISHED;
                cout `[$(_data.fInfo)]: $(_data.desc)\n`;
                cout `$(_vOutput.createString())`;
                cout `$(_output.createString())\n`;

                pass = true;
                for (b :in _harness) {
                    if ((b.crackResult && !b.crackResult.pass) ||
                        (b.binaryResult && !b.binaryResult.pass))
                        pass = false;
                }

                if (config.stopOnFail && !pass) {
                    // XXX close procs nicely?
                    exit(0);
                }
            }

        }

        return _status;

    }

    oper init(FileInfo info, DirConfig dc) {
        _data.fInfo = info;
        _data.dirConfig = dc;
        _data.sections = Template.load(info.name);
        if (_data.sections is null) {
            _isSkipped = "unabled to open file";
            _status = T_FINISHED;
            return;
        }
        checkTemplate();
        // setup test harnesses for this test, based on the builders
        // that have been selected
        for (b :in config.builders) {
            _harness.append((CrackBuilderDef.cast(b)).newTestHarness(_data));
        }
    }

    void _dump(Writer out) {
        for (t :in _data.sections)
            Formatter(out) `[$(t.key)]:\n$(t.val)`;
    }

    void writeTo(Writer out) {
        Formatter(out) `[$(_data.fInfo)]: $(_data.desc)\n`;
    }

}

// handle command line
// find all tests
// handle queue of active tests
// decide which builders to run
class TestSuite {

    PriorityQueue[Test] _testList = {};
    CmdOptions _options = {};
    
    void usage() {
        _options.printUsage(FStr() `Usage: $(argv[0]) -c <crack binary> [options]\n`);
        exit(1);
    }
    
    DirConfig getDirConfig(Directory dir) {

        // directory based config
        DirConfig dc;
        dcFile := FileInfo(dir.nameWithTrailing() + "options");
        if (dcFile.exists()) {
            sec := Template.load(dcFile.name);
            if (sec.contains("OPTS")) {
                dc = DirConfig();
                dc.options = sec["OPTS"].rtrim();
            }
        }

        return dc;

    }

    void scanForTests(Directory dir) {
    
        if (!dir.isValid()) {
            cerr `skipping invalid directory: $dir\n`;
            return;
        }
        
        cout `importing tests from $dir ... `;

        dc := getDirConfig(dir);

        // gather test files
        cnt := 0;
        for (curFile :in dir.files()) {
            if (curFile.matches("*.crkt")) {
                cnt++;
                _testList.push(Test(curFile, dc));
            }
        }

        cout `found $cnt\n`;
        
        // recurse to directories
        for (nextDir :in dir.dirs()) {
            scanForTests(nextDir);
        }

    }

    void runTests() {

        if (_testList.count() == 1)
            cout `running single test`;
        else
            cout `running $(_testList.count()) total tests in $(config.jobs) concurrent jobs`;
        cout ` with output in $(config.outDir)...\n`;

        bool reap(Test t) { return t.tick() != T_FINISHED; }

        Array[Test] active = {};
        Test cur;
        while (_testList.count() || active.count()) {

            // check active for finished tests, remove
            active.filter(reap);

            // add to active if active.count <= max
            while (_testList.count() &&
                   active.count() < config.jobs) {
                cur = _testList.pop();
                active.append(cur);
                cur.run();
            }

        }

    }

    oper init() {
        
        StringArray bDefStrings = {};
        for (i :in builderDefList) {
            bDefStrings.append(i.key);
        }
        String availBuilders = bDefStrings.join(',');

        _options.add("crackbin", "c", "Crack binary to test", "", CMD_STR);
        _options.add("help", "h", "Show usage", "f", CMD_BOOL);
        _options.add("verbose", "v", "Show verbose output", "f", CMD_BOOL);
        _options.add("jobs", "j", "Number of concurrent jobs", "4", CMD_INT);
        _options.add("testdir", "d", "Directory to search recursively for tests", "./tests", CMD_STR);
        _options.add("testfile", "f", "Single test template to execute", "", CMD_STR);
        _options.add("outdir", "o", "Directory to create output files", "./output", CMD_STR);
        _options.add("libpath", "l", "Add path to crack library path during test. May be colon seperated list.", "", CMD_STR);
        _options.add("builders", "b", "Builders to test, comma delimited list ["+availBuilders+"]","jit", CMD_STR);
        _options.add("diff", "", "Show a diff of expected vs actual output if a test fails","f", CMD_BOOL);
        _options.add("stop-on-fail", "", "Stop on first test failure and display diff","f", CMD_BOOL);
        _options.parse(argv);
                
        if (_options.getBool("help"))
            usage();

        // binary - required
        config.crackBin = _options.getString("crackbin");
        if (config.crackBin == "") {
            cerr `you must explicitly specify the crack binary via the -c option\n\n`;
            usage();
        }
        
        config.rootDir = Directory(_options.getString("testdir"), false);
        config.outDir = Directory(_options.getString("outdir"), false);

        config.libPath = _options.getString("libpath");
        config.verbose = _options.getBool("verbose");
        config.jobs = _options.getInt("jobs");
        config.showDiff = _options.getBool("diff");
        config.stopOnFail = _options.getBool("stop-on-fail");

        if (config.stopOnFail)
            config.showDiff = true;

        // verify, initialize builder defs
        builders := _options.getString("builders");
        clb := split(builders, ",");
        for (b :in clb) {
            if (bDefStrings.contains(b)) {
                config.builders.append(builderDefList[b]);
            }
            else {
                cout `invalid builder specified: $b`;
                exit(1);
            }
        }

        testFile := _options.getString("testfile");
        if (testFile != "" && config.rootDir.isValid()) {
            // if specific file, clear directory
            config.rootDir = null;
            fi := FileInfo(testFile);
            if (!fi.exists()) {
                cerr `$testFile does not exist\n`;
                exit(1);
            }
            test := Test(fi, getDirConfig(Directory(fi.dirname())));
            _testList.push(test);
            config.showDiff = true;
            config.jobs = 1;
        }

        // banner
        cout `screen\n`;

        // check binary
        cfi := FileInfo(config.crackBin);
        if (!cfi.exists()) {
            cout `crack binary [$(config.crackBin)] not found\n`;
            exit(1);            
        }
        
        p := Process(config.crackBin+" --version");
        p.wait();
        String out = {};
        if (!p.failed())
            out = p.getStdOut();        
        if (p.failed() || p.getReturnCode() != 0) {
            cout `crack binary [$(config.crackBin)] failed to run, or unexpected result\n`;
            exit(1);
        }
        else if (out.size < 5 || out.slice(0,5) != "crack") {
            cout `crack binary [$(config.crackBin)] invalid version response: $(out.slice(0,5))\n`;
            exit(1);
        }
        else {
            cout `using binary: $out\n`;
        }
        
    }
    
    void run() {
        
        if (config.rootDir)
            scanForTests(config.rootDir);

        if (!config.outDir.isValid()) {
            cerr `invalid output directory: $(config.outDir)\n`;
            return;
        }

        runTests();
        
    }

}

suite := TestSuite();
suite.run();
