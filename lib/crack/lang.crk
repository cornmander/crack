#!/usr/bin/crack
# Copyright 2010 Google Inc.

import "libc.so.6" free, strlen, strdup, malloc, memcpy, memcmp, abort;

byteptr malloc(uint size);
byteptr memcpy(byteptr dest, byteptr src, uint size);
int memcmp(byteptr a, byteptr b, uint size);
void free(voidptr mem);
uint strlen(byteptr buf);
byteptr strdup(byteptr buf);
void abort();

bool true = (1 == 1);
bool false = (1 == 0);

class XWriter : VTableBase {
    void write(byteptr buf, uint size) {
        puts("XWriter.write() called.");
        abort();
    }
};

## Base class for things that you don't want derived from object or VTableBase.
class FreeBase {};

## The Object base class.  Object provides the basic reference counting 
## mechanism, and most user classes should be derived from it.
class Object : VTableBase {
    uint refCount;

    oper init() : refCount = 0 {
    }

    # delete virtual function
    oper del() { 
        if (refCount) {
            puts("Object with non-zero ref count deleted!");
            abort();
        }
    }

    oper bind() {
        if (!(this is null))
            refCount = refCount + 1;
    }
    
    oper release() {
        if (this is null)
            return;

        refCount = refCount - 1;
        if (refCount == 0) {
            # XXX more overloading nonsense
            this.__del();
            free(this);
        }
    }
    
    bool isTrue() {
        return true;
    }
    
    ## Comparison function - returns a value < 0 if this < other, 0 if this is 
    ## equal to other, > 0 if this > other.
    int cmp(Object other) {
        if (this is other) return 0; else return 1;
    }
    
    bool toBool() {
        if (this is null)
            return false;
        else
            return isTrue();
    }
    
    void writeTo(XWriter writer) {
        writer.write("<Object>", 8);
    }
};

## The buffer base class containing a bytebuf and size.
class Buffer : Object {

    // buffer and size.
    uint size;    
    byteptr buffer;

    oper init(byteptr buffer0, uint size0) : buffer = buffer0, size = size0 {}
    
    bool isTrue() {
        return size;
    }
    
    void writeTo(XWriter writer) {
        writer.write(buffer, size);
    }
};

## A writable buffer.  You can assume that it is safe to write to one of these.
class WriteBuffer : Buffer {
    
    ## constructor inheritence would be nice
    oper init(byteptr buffer, uint size) : Buffer(buffer, size) {}
};

## A managed buffer.  Deletes the bytebuf when it goes out of scope.
class ManagedBuffer : WriteBuffer {

    oper init(uint size) : WriteBuffer(malloc(size), size) {}

    ## Orphan's the byte buffer, returning it for use by the caller.  The 
    ## caller is responsible for freeing it.
    byteptr orphan() {
        temp := buffer;
        buffer = null;
        return temp;
    }

    oper del() {
        if (!(buffer is null))
            free(buffer);
    }
};

## The string class.  Strings are immutable managed Buffer's - when they are 
## deleted, their buffer goes away.
class String : Buffer {

    ## Initialize from a buffer
    oper init(Buffer buf) : Buffer(malloc(buf.size), buf.size) {
        memcpy(buffer, buf.buffer, buf.size);
    }

    ## Initialize from a WriteBuffer and take ownership (takeOwnership is 
    ## actually ignored).
    oper init(ManagedBuffer buf, bool takeOwnership) : 
        Buffer(buf.orphan(), size) {
    }
    
    ## Initialize from byte pointer and size and take ownership.
    oper init(byteptr buf, uint size, bool takeOwnership) :
        Buffer(buf, size) {
    }
    
    ## Initialize from a null-terminated c-string
    oper init(byteptr cString) : Buffer(malloc(size + 1), strlen(cString)) {
        memcpy(buffer, cString, size);
    }

    ## Create an empty string.
    oper init() : Buffer(malloc(0), 0) {}
    
    void _freeBuffer() {
        free(buffer);
    }
    
    oper del() {
        _freeBuffer();
    }

    ## This needs to accept Object, we need type casts to be able to implement 
    ## that interface.
    int cmp(String other) {
        if (size > other.size)
            return memcmp(buffer, other.buffer, other.size);
        else
            return memcmp(buffer, other.buffer, size);
    }
};

class StaticString : String {

    oper init(byteptr data, uint size) : String(data, size, true) {}
    
    # override _freeBuffer so we don't...
    void _freeBuffer() {}
};

void print(String val) {
    puts(val.buffer);
}

void die(String message) {
    print(message);
    abort();
}
