// Command line argument processor
// Copyright 2011 Conrad Steenberg <conrad.steenberg@gmail.com>

import crack.lang die, cmp, free; 
import crack.container Array;
import crack.math strtoi, strtof;
import crack.lang Exception, InvalidArgumentError, BadCastError, IndexError;
import crack.sys argv, StringArray;
import crack.io cout, Formatter, FStr;
@import crack.exp.cont.array GenericObjArray, GenericPrimArray, GenericArray;


uint CMD_STR = 0;
uint CMD_INT = 1;
uint CMD_FLOAT = 2;
uint CMD_BOOL = 3;
uint NOINDEX = 0xffffffff; // Completely arbitrary a large number

StringArray splitString(String s, byte sep) {
   StringArray result = {256};
   uint count = 0;
   int pos = 0;

   while (true) {
      end := s.lfind(sep, uint(pos));
      if (end != -1) {
          result[count++]=s.slice(pos, end);

      } else {
          result[count++]=s.slice(pos);
          break;
      }
      pos = end + 1;
   }

   StringArray real = {count};
   for (uint i=0; i< count; i++) real[i] = result[i];
   return real;
}

class Option {
   String long;
   String short;
   String desc;
   uint type;
   uint pos = NOINDEX; // index in option array
   String value;

   oper init(uint type):
      type(type),
      value = "" {}

   oper init(String long, String short, String desc, String value, uint type):
      long = long,
      short = short,
      desc = desc,
      type = type,
      value = value {}

   oper init(String long, String short, String desc, String value, uint type):
      long = long,
      short = short,
      type = type,
      value = value {}

   oper init(String long, String short):
      long = long,
      short = short,
      desc = "",
      type = CMD_STR,
      value = "" {}

   int cmp(Option other){
      return long.cmp(other.long);
   }

// Setters
   void setInt(int value0){
      value = FStr() `$value0`;
   }

   void setFloat(float value0){
      value = FStr() `$value0`;
   }

   void setBool(bool value0){
      value = FStr() `$value0`;
   }

   void setString(String value0){
      value = value0;
   }

   void set(String value0){
      if (type == CMD_BOOL){
         if (value0 == 't' || value0 == 'true' || value0 == '1')
            value = "1";
         else 
            if (value0 == 'f' || value0 == 'false' || value0 == '0')
               value = "0";
            else
               throw BadCastError(FStr() `Invalid value '$(value0)' for boolean option`);
         return;
      } 
      else if (type == CMD_INT)
         strtoi(value0);
      else if (type == CMD_FLOAT)
         strtof(value0);
      value = value0;
   }
}

@GenericObjArray(OptionArray, Option)
@GenericPrimArray(ByteArray, byte)

// Command line options tree
class CmdOptions : Object{
   OptionArray options; // Contains option objects
   bool sorted = false;

   oper init(): options()
   {  }
   
   void add(Option newoption){
      options.append(newoption);
   }

   Option add(String long, String short, String desc, String value, uint type){
      newoption := Option(long, short, desc, value, type);
      add(newoption);
      return newoption;
   }

   // Forward declaration
   StringArray parse(StringArray args, bool createUnknown);

   // Convenience method to add options based on a specification string
   StringArray addFromString(String line){
      new_argv := splitString(line, b' ');
      return parse(new_argv, true);
   }
   
   // Linear search for now
   uint findLongIndex(String optName){
      result := NOINDEX;
      Option opt;

      for (uint i=0; i<options.count(); i++){
         if (optName == options[i].long) return i;
      }

      return result;
   }

   uint findShortIndex(byte optName){
      result := NOINDEX;

      for (uint i=0; i<options.count(); i++)
         if (optName == options[i].short[0]) return i;

      return result;
   }


   // Generalized get
   Option getOption(String optName, bool throwException){
      index := NOINDEX;
      Option option = null;

      if (optName.size==1)
         index = findShortIndex(optName[0]);
      else
         index = findLongIndex(optName);
      if (index != NOINDEX) return options[index];
      else if (throwException) {
         throw IndexError(FStr() `Option '$optName' not found`);
      }
      return option;
   }
   
   Option getOption(String optName){
      return getOption(optName, true);
   }

   Option getOption(String optName){
      return getOption(optName, true);
   }

   Option oper [](String optName){
      return getOption(optName, true);
   }

   Option oper [](String optName){
      return getOption(optName, true);
   }


   // Getters 
   int getInt(String optName){
      Option opt = getOption(optName);
      if (opt.type != CMD_INT) throw InvalidArgumentError(FStr() `Attempting to fetch non-integer '$optName' option as an integer`);
      return strtoi(opt.value);
   }

   float getFloat(String optName){
      Option opt = getOption(optName);
      if (opt.type != CMD_FLOAT) throw InvalidArgumentError(FStr() `Attempting to fetch non-float option '$optName' as a float`);
      if (!opt.value) return 0.0;
      return strtof(opt.value);

   }

   bool stringAsBool(String value){
      if (value == "1" || value == "t" || value == "true")
         return true;
      else 
         return false;
   }

   bool getBool(String optName){
      Option opt = getOption(optName);

      if (opt.type != CMD_BOOL) throw InvalidArgumentError(FStr() 
         `Attempting to fetch non-bool option '$optName' as a bool`);
      
      return stringAsBool(opt.value);
   }

   String getString(String optName){
      return getOption(optName).value;
   }

   StringArray _getPair(StringArray args, uint argi){
      StringArray result = {2};
      arg := args[argi];
      len := arg.size;
      if (len == 1) return result;
      prefix := arg.slice(0,2);
      
      if (prefix[0] == b'-' && len > 1) {
         if (len > 2 && prefix[1] == b'-'){ // long option found
            eqi := arg.lfind(b'=', 3);
            if (eqi > 2){ // Found a value after = sign
               result[0] = arg.slice(2, eqi);
               result[1] = arg.slice(eqi+1);
            }
            else
               result[0] = arg.slice(2);
         }
         else {
            result[0] = arg.slice(1);
            if (argi < args.count()-1 && args[argi+1] != '-'){
               result[1] = args[argi+1];
            }
         }
      }
      return result
   }

   /// Create a new option from a name/value pair
   /// pair[0]: name of the option
   /// pair[1]: string value of the option
   ///          for CMD_BOOL options a null means the option is getting set
   ///          i.e. true

   ///          The value can use a shorthand to define unknown options
   ///          b/value: a boolean with the given value, e.g. b/0, b/true, b/false
   ///                   the values 1, t, and true are all true and
   ///                   0, f, and false are all false
   ///          i/value: integer values
   ///          f/value: float values
   ///          s/value: string value, this is the default if no type specifier
   ///                   is given
   ///          Uppercase type specifiers are also acceptable (B, I, F, S).
   Option _addNewOption(String name, String value){
      if (!name)
         throw InvalidArgumentError(FStr() `Error: trying to create new option with null name`);

      uint newType = 100;
      int startInd = 0;
      Option opt = null;

      // Check for special typed syntax
      if (!value || value.size==0) newType = CMD_BOOL;
      else if (value.size > 2 && value[1] == b'/'){
         if (value[0] == b'B' || value[0] == b'b') newType = CMD_BOOL;
         else if (value[0] == b'I' || value[0] == b'i') newType = CMD_INT;
         else if (value[0] == b'F' || value[0] == b'f') newType = CMD_FLOAT;
         else if (value[0] == b'S' || value[0] == b's') newType = CMD_STR;
         startInd = 2;
      }
      else // Default is a simple string option
         newType = CMD_STR;

      if (newType<100 && name.size>0){
         try {
            if (value)
               opt = Option(name, name.slice(0, 1), "", 
                            value.slice(startInd), 
                            newType
                            );
            else if (newType == CMD_BOOL)
               opt = Option(name, name.slice(0, 1), "", "1", newType);
            else throw InvalidArgumentError(FStr() `While setting new option '$(name):'`);
         } catch (Exception ex){
            String newMsg = FStr() `$(ex.text) invalid new option format '$(value)'`;
            throw InvalidArgumentError(newMsg);
         }
         add(opt);
         return opt;
      }
      else throw Exception(FStr() `Unrecoverable error in creating new option`);
   }
   
   // Parse the array obtained from sys.argv
   StringArray parse(StringArray args, bool createUnknown){
      StringArray unparsed={args.count()};
      uint argi, unpi = 0;
      Option opt;
      bool isnew = false;
      String name, value;

      for (argi=0; argi < args.count(); argi++){
         opt = null;
         pair := _getPair(args, argi);
         name = pair[0];
         value = pair[1];
         
         isnew = false;
         if (name) {
            // Look up 
            try {
               opt = getOption(name);
            } catch (IndexError ix){
               if (createUnknown) isnew = true;
               else throw IndexError(ix.text);
            }

            if (opt){
               if (!value || opt.type == CMD_BOOL){
                  if (opt.type == CMD_BOOL){ // ignore value, we'll parse it next
                     opt.setString("1");
                     continue;
                  }
                  throw InvalidArgumentError(FStr() `Option $(args[argi]) given without a value`);
               } else {
                  if (args[argi][1] != b'-') 
                     argi++;
                  if (isnew) opt = _addNewOption(name, value);
                  else opt.setString(value);
               }
            }
            else if (isnew){
               _addNewOption(name, value); // Creates the option and sets the value
            }
         }
         else {
            unparsed[unpi++] = args[argi];
         }
      }
      return unparsed;
      
   }

   void dump(){
      for (uint i = 0; i < options.count(); i++){
         Option opt = options[i];
         if (opt.value)
            cout `$(opt.short)/$(opt.long) [$(opt.type)] = $(opt.value)\n`;
         else
            cout `$(opt.short)/$(opt.long) [$(opt.type)] = (null)\n`;
      }
   }

   void printUsage(String intro){
      Array typeNames = ["string", "int", "float", "bool"];
      cout `$(intro)\n`;
      uint i;

      for (i = 0; i < options.count(); i++){
         Option opt = options[i];
         String value = opt.value;
         if (!value)
            value = "null";
         if (opt.type != CMD_BOOL){
            cout ` -$(opt.short) ARG --$(opt.long)=ARG \t`;
            cout` $(opt.desc)  ($(typeNames[opt.type]): $(value))\n`;
         }
         else {
            cout ` -$(opt.short) --$(opt.long) \t\t`;
            cout` $(opt.desc)  ($(typeNames[opt.type]): $(stringAsBool(value))\n`;

         }
      }
      
      if (i>0) cout `\n`;
   }
}
