# Copyright 2011 Google Inc
# Generic array implementation

import crack.lang cmp, free, IndexError, InvalidArgumentError;
import crack.io cout, Writer, FStr;
import crack.exp.algorithm QuickSort;
@import crack.exp.ann define;

void _bind(Object obj) { obj.oper bind(); }
void _release(Object obj) { obj.oper release(); }
bool _isObject(Object obj) { return true; }
bool _isNull(Object obj) {
    return (obj is null);
}

@define _nobind(type) { 
    void _bind(type i) { }
    void _release(type i) { }
    bool _isObject(type i) { return false; }
    bool _isNull(type i) { return false; } 
}

@_nobind(byte)
@_nobind(int)
@_nobind(int32)
@_nobind(uint)
@_nobind(uint32)
@_nobind(int64)
@_nobind(uint64)
@_nobind(float)
@_nobind(float32)
@_nobind(float64)
@_nobind(byteptr)

# A class to keep track of the primitive array needed for the Array[Elem] class
class ArrayData[Elem] {
    array[Elem] rep = null;
    uint cap;
    
    oper init(uint cap): cap(cap), rep = array[Elem](cap) {
    }

    void releaseAll(){
        if (cap > 0 && _isObject(rep[0])){
            for (uint i = 0; i < cap; i++) {
                if (!_isNull(rep[i])) 
                    _release(rep[i]);
            }
        }
    }


    @final
    oper del(){
        if (!(rep is null)) 
            releaseAll();
    }
}

## An Array is a sequence backed by a low-level array.  It supports the 
## bracket operators and adding items at the end.
class Array[Elem] {
    ArrayData[Elem] data;
    array[Elem] __rep = null;
    uint __cap, __size;

    @final
    void oper []=(uint index, Elem elem) {
        if (index >= __size)
            throw IndexError('Index out of range in Array.oper []=');
        
        tmp := __rep[index];
        __rep[index] = elem;
        _bind(elem);
        _release(tmp);
    }

    @final
    void oper []=(int index, Elem elem) {
        uint i;
        if (index < 0)
            i = __size + uint(index);
        else
            i = uint(index);

        tmp := __rep[i];
        __rep[i] = elem;
        _bind(elem);
        _release(tmp);
    }

    @final
    uint count() {
        return __size;
    }

    @final
    Elem oper [](uint index) {
        if (index >= __size)
            throw IndexError('Index out of range in Array.oper []');
        
        return __rep[index];
    }

    @final
    Elem oper [](int index) {
        uint i;
        if (index < 0)
            i = __size + uint(index);
        else
            i = uint(index);
        
        return this[i];
    }

    @final
    Elem last() { return __rep[__size - 1]; }
    
    int cmp(Object other) {
        if (this is other)
            return 0;
        else if (!this.isa(Array))
            return Object.cmp(other);
        
        peer := Array.cast(other);

        c := count();
        oc := peer.count();
        for (int i = 0; i < c; ++i) {
            
            # if I'm longer than other, and we share a common prefix, I'm 
            # greater.
            if (i > oc)
                return 1;
            
            # compare the elements
            elemDiff := cmp(this[i], peer[i]);
            if (elemDiff)
                return elemDiff;
        }
        
        # if other is longer than me, and we share a common prefix, I'm lesser.
        if (oc > c)
            return -1;
        else
            # we're the same length and all elements are equal
            return 0;
    }
    
    void sort(){
        QuickSort[Array] qs = {this, __size};
    }

    class ArrayIter {
        Array __arr;
        uint __index;
        bool __first = true;
    
        oper init(Array arr) : __arr = arr {}
        

        Elem elem() {
            return __arr[__index];
        }

        @final
        bool next() {
            cnt := __arr.count();
            if (__index < cnt) {
                __index = __index + 1;
                return __index < cnt;
            } else {
                return false;
            }
        }

        @final
        bool nx() {
            if (__first) {
                __first = false;
                return __index < __arr.count();
            } else {
                return next();
            }
        }
        
        bool isTrue() {
            return __index < __arr.count();
        }
    }
    
    oper init(uint initCapacity) :
        data = ArrayData[Elem](initCapacity), 
        __rep = data.rep,
        __cap = initCapacity,
        __size = 0 {
    }
    
    oper init() : 
        data = ArrayData[Elem](16), 
        __rep = data.rep,
        __cap = 16,
        __size = 0 {
    }

    oper init (ArrayData[Elem] data, array[Elem] rep, uint cap, uint size):
        data = data,
        __rep = rep, // data.rep <= rep <= rep + cap
        __cap(cap),
        __size(size){
    }

    void realloc(uint newCapacity) {
        uint newCap = newCapacity;
        if (newCap < __cap)
            throw InvalidArgumentError('Array.realloc() - decreasing capacity');
        if (newCap == 0) newCap = 16;
        newData := ArrayData[Elem](newCap);
        newRep := newData.rep;
        
        # move all of the entries to the new array.
        uint i;
        while (i < __size) {
            newRep[i] = __rep[i];
            i = i + 1;
        }

        data = newData;
        __rep = newRep;
        __cap = newCap;
    }
    
    Array copy(){
        newData := ArrayData[Elem](__cap);
        newRep := newData.rep;
        
        # move all of the entries to the new array.
        uint i;
        while (i < __size) {
            newRep[i] = __rep[i];
            i = i + 1;
       }

       return Array(newData, newRep, __cap , __size);
    }

    @final
    void append(Elem elem) {
        if (__size == __cap)
            realloc(__cap * 2);
        __rep[__size] = elem;
        _bind(elem);
        __size = __size + 1;
    }

    Elem pop() {
       if (__size>0)
          return __rep[--__size];
       else
          return null;
    }

  @final
    ArrayIter iter() {
        return ArrayIter(this);
    }
    
    uint capacity() {
        return __cap;
    }

    void writeTo(Writer out) {
        FStr fmt = {};
        out.write('[');
        bool first = true;
        for (elem :in this) {
            if (!first)
                out.write(', ');
            else
                first = false;
            if (_isNull(elem)) out.write('null');
            else {
                text := fmt `$elem`;
                out.write(text);
            }
        }
        out.write(']');
    }


    Array _subarray(uint pos, uint len){
        if (pos > __size || pos + len > __size)
            throw IndexError('Subarray out of bounds');

        array[Elem] newrep = __rep + uintz(pos);
        return Array(data, newrep, __cap - pos, len);
    }


    Array subarray(int pos, uint len) {
        # adjust a negative position
        if (pos < 0)
            pos = int(__size) + pos;

        return _subarray(uint(pos), len);
    }

    Array subarray(uint pos, uint len) {
        return _subarray(pos, len);
    }


    Array subarray(int pos) {
        # adjust a negative position
        if (pos < 0)
            pos = int(__size) + pos;

        return _subarray(uint(pos), __size - uint(pos));
    }

    Array subarray(uint pos) {
        return _subarray(pos, __size - pos);
    }

    Array slice(int start, int end) {
        # adjust negative offsets
        if (start < 0)
            start = int(__size) + start;
        if (end < 0)
            end = int(__size) + end;

        # bounds checking
        if (end < start)
            throw IndexError('Start of slice is after end.');

        return _subarray(uint(start), uint(end - start));
    }

    Array slice(uint start, uint end) {
        # bounds checking
        if (end < start)
            throw IndexError('Start of slice is after end.');

        return _subarray(start, end - start);
    }


    Array slice(int start) {
        # adjust negative offsets
        if (start < 0)
            start = int(__size) + start;

        # bounds checking
        if (uint(start) > __size)
            throw IndexError('Start of slice is after end.');

        return _subarray(uint(start), __size - uint(start));
    }

    ## swap element index1 with index2
    void swap(uint index1, uint index2) {
        if (index1 > __size || index2 > __size)
            throw IndexError('Index out of range in Array.swap()');
        if (index1 == index2)
            return;
        tmp := __rep[index2];
        __rep[index2] = __rep[index1];
        __rep[index1] = tmp;
    }

    ## delete the element at 'index'.
    void delete(uint index) {
        if (index > __size)
            throw IndexError('Index out of range in Array.delete()');
        
        # release the object at the index
        elem := __rep[index];
        _release(elem);
        
        # move everything else down one
        uint i = index;
        while (i < __size - 1) {
            __rep[i] = __rep[i + 1];
            ++i;
        }
#        memmove(__rep + index, __rep + index + 1, __size - index);
        --__size;
    }   
}
