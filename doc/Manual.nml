
The Crack Programming Language Guide
====================================

If you're reading this, you're one of the intrepid folks who have downloaded 
the Crack 0.1 programming language.  Thanks!  Before we get into telling you 
about the language, there's something you need to be aware of:  Crack 0.1 is 
very much alpha-quality code.  Lots of very basic language features haven't 
been implemented yet.  There are lots of bugs, some known, some yet to be 
discovered.  There's no debug info, stack traces, or anything else that you 
might use to make your life easier.  If you're looking for a language to do 
serious development in, Crack 0.1 ain't it.

But that said, if you want to get in on the ground floor of a new scripting 
language that is C-like, fast, and interfaces well with C and C++ code, Crack 
is the language and this version is definitely the ground floor.  We're 
releasing it mainly to get attention.  The language exists, we believe it 
will (eventually) rock, and we'd love to have people banging on it and giving 
us feedback.

So without further caveats - let's do some Crack!

Installation
------------

See the INSTALL file for the latest installation instructions.

Hello World
-----------

Here's the crack "hello world" program:

{{
    #!/usr/local/bin/crack
    import crack.io cout;
    cout `hello world!\n`;
}}

If you write this as a script and "chmod u+x" it, when you run it you should 
see "hello world!" written to the terminal.

The first line is the standard unix "`#!`" line.  It tells the kernel to 
execute the script by passing its full name as an argument to the 
"`/usr/local/bin/crack`" program.

The second line imports the "#cout#" variable from the #crack.io# module.  
Like C++, Crack uses "#cin#", "#cout#" and "#cerr#" for its standard input, 
output and error streams.  "#cout#" and "#cerr#" are both "formatters," which 
means that they support the use of the back-tick operator for formatting.

The third line actually uses the back-tick operator to print some text.  We 
won't go into too much detail on this operator right now - suffice it to say 
that this line is roughly equivalent to "#cout.format('hello world!\n');#"  
The "\n" at the end of the string translates into a newline (the ASCII "LF" 
character, character code 10).

Comments
--------

Crack permits the use of C, C++ and shell style comments:

{{
    /* C Style comment */
    // C++ style comment
    # shell style comment
}}

For code that you hope to get a lot of re-use out of, we recommend the 
convention of Doxygen-style doc-comments for classes, functions and global 
variables:

{{
    /** C-style doc-comment */
    /// C++ style doc-comment
    ## shell-ish doc-comment
}}

These currently get treated the same as any other comments.  However, future 
versions of Crack will parse them and store them with the meta-data for the 
code, permitting the easy extraction of reference documentation from the 
source.

Variables and Types
-------------------

Like most languages, Crack allows you to define variables:

{{
    # define the variable i and initialize it to 100.
    int i = 100;
}}

You can also define variables using the more terse ":=" operator:

{{
    i := 100;           # equivalent to "int i = 100;"
    j := uint32(100);   # equivalent to "uint32 j = 100;"
}}

If you don't specify an initializer for a variable, the default initializer 
will be used.  For the numeric types, this is zero.  For #bool#, it's #false#. 
For complex types (which we'll discuss later), the default constructor is 
used to create a new instance.

Built-in Types
''''''''''''''

The Crack language defines the following set of built-in types - these can be 
expected to exist in every namespace without requiring an explicit import:

void::
    The "void" type - this only exists so you can have a function that doesn't 
    return anything.  Bad things will happen if you try to define void 
    variables. 
byte::
    An 8-bit unsigned integer.
bool::
    A boolean.  Values are *true* and *false*, which are built-in variables.
int32::
    A 32-bit signed integer.
uint32::
    A 32-bit unsigned integer.
int64::
    A 64-bit signed integer.
uint64::
    A 64-bit unsigned integer.
float32:
    A 32-bit floating point.
float64::
    A 64-bit floating point.
int::
    An integer of the C compiler's default int-size for the platform (this is 
    an alias to either int32 or int64).
uint::
    An unsigned integer of the C compiler's default unsigned int-size for the 
    platform (this is an alias to either uint32 or uint64).
float::
    A floating point of the C compiler's float size for the platform.
byteptr::
    A pointer to an array of bytes.
voidptr::
    A pointer to anything.  All high level classes can implicitly convert to 
    voidptr.
array[class]::
    The low-level array type.  You should generally avoid using this in favor 
    of high-level datastructures.

    This is Crack's only existing generic datatype - to use it, you specialize 
    it with another class type, for example: #array[int]#
VTableBase::
    The base class used for all classes that have a vtable (more on this 
    later).
Object::
    The implicit base class of all classes that don't define base classes.
String::
    A string of bytes.
StaticString::
    This is a String whose buffer can point to read-only memory.
Class::
    The meta-class for all class objects.

Of these, the #byte#, #bool#, #int#, #uint# and #float# types (including all 
variations of #int#, #uint# and #float#) are /primitives/.  These types are 
notable in that they are copy-by-value and consume no memory external to the 
scope in which they are defined.

The #byteptr#, #voidptr# and #array# types are classified as /primitive 
pointer/ types.  

Primitive types, primitive pointer types, and the #void# type are all 
classified as /low-level/ types.  They are distinguished from the higher 
level aggregate types by naming convention: low-level types will always be all 
lower case (and digits), high-level types (at least the ones in the standard 
libraries) will always begin with an upper-case character.  You may not 
currently subclass low-level types, this restriction will be lifted in a 
future version of Crack.

/High level/ or /aggregate/ types are first class objects: variables of this 
type are pointers to allocated regions of memory large enough to accomodate 
the state data defined for the type.  They can be extended to create other 
high-level types through sub-classing (more on this later).

Implicit Conversion
'''''''''''''''''''

XXX talk about conversion in general

Numeric types will implicitly convert between one another as long as there is 
no risk of precision loss.  In cases where there is a risk of precision loss, 
you can use explicit construction to force a conversion - truncating the value 
if necessary.

{{
    # implicit conversions
    byte b;
    int32 i32 = b;
    uint32 u32 = b;
    int64 i64 = i32;
    i64 = u32;
    uint64 u64 = u32;
    float32 f32 = b;
    float64 f64 = i32;
    f64 = u32;
    
    # explicit conversions
    i32 = int32(i64);
    b = byte(f32);
    i64 = int64(u64);
}}

Strings
'''''''

Most programming languages support strings of characters, which are usually 
implemented as some kind of array.  Crack strings are strings of bytes - you 
can embed any kind of byte values you want in them, there are no assumptions 
about encoding.

String constants are sequences of bytes enclosed in single or double quotes:

{{
    String s = "first string";
    t := 'second string';
}}

String constants actually instances of the "StaticString" class - they're just 
like strings except since their buffers are constants, they don't try to 
deallocate them on destruction.

Control Structures
------------------

Crack 0.1 only supports two control structures: the "if/else" statement and 
the "while" statement.  "if" runs code blocks depending on whether a condition 
is true or false:

{{
    import crack.io cout;
    if (true)
        cout `true is true\n`; 
    else
        cout `something is wrong\n`;
}}

The code above will always print out "true is true".  

If we wanted to do something a little more useful, we could have used it to 
check the command line argument:

{{
    import crack.sys argv;
    import crack.io cout;
    
    if (argv.count() > 1 && argv[1] == 'true')
        cout `arg is true\n`;
    else
        cout `arg is false\n`;
}}

There's a lot of new stuff going on here: first of all, we're importing the 
"argv" variable form #crack.sys#.  This variable contains the program's 
command line arguments.

#count()# is a method that returns the number of items in argv.  #argv[1]# 
accesses item 1 of the argument list (indexes are zero-based, so item 1 is the 
second element of the sequence).

The "&&" is a short-circuit logical and: it returns true if both of the 
expressions are true, but it won't evaluate the second expression unless the 
first is true.  This is important in this case, because if we were to check 
#argv[1]# in a case where #argv# had less than two elements, a fatal error 
would result.

The #if# statement need not be accompanied by an else:

{{
    if (argv.count() > 1 && argv[1] == 'true')
        cout `arg is true\n`;
    cout `this gets written no matter what the args are\n`;
}}

The code in an #if# or an #else# can either be a single statement, or a 
sequence of statements enclosed in curly braces:

{{
    if (argv.count() > 1 && argv[1] == 'true') {
        cout `arg is true\n`;
        cout `and so are you!\n`;
    }
}}

You can also chain if\/else blocks:

{{
    argCount := argv.count();
    if (argCount > 2)
        cout `more than one arg\n`;
    else if (argCount > 1)
        cout `just one arg\n`;
    else
        cout `no args.\n`;
}}

The while statement
'''''''''''''''''''

The #while# statement repeatedly executes the same code block while the 
condition is true.  For example, we could iterate over the list of arguments 
with the following code:

{{
    import crack.sys argv;
    import crack.io cout;
    
    uint i;
    while (i < argv.count()) {
        cout `argv $i: $(argv[i])\n`;
        i = i + 1;
    }
}}

Note that the code in the while is enclosed in curly braces.  In general, the 
code managed by a control structure can either be a single statement, or a 
group of statements enclosed in curly braces.  The #if# statement works the 
same way.

This example also introduces the primary feature of the back-tick operator: 
variable interpolation.  A dollar sign followed by a variable name formats the 
variable.  A dollar sign followed by a parenthesized expression formats the 
value of the expression.

Functions
---------

Functions let you encapsulate common functionality.  They are defined with a 
type name, an argument list, and a block of code, just like in C:

{{
    int factorial(int val) {
        if (val == 1)
            return 1;
        else
            return val * factorial(val - 1);
    }
}}

Also note that Crack supports recursion: you can call a function from within 
the definition of that function.

You can define a function that doesn't return a value by using the special 
"void" type:

{{
    void printInt(int i) {
        cout `$i\n`;
    }
}}

Primitive types are always passed "by value."  The system makes a copy of them 
for the function.  This fact is academic in Crack 0.1, because parameters 
can't be modified anyway.

Multiple functions can share the same name as long as their arguments differ: 
this feature is called /overloading/.  For example, rather than "#printInt#" 
above, we could have defined a #print# function for multiple types:

{{
    void print(int64 i) {
        cout `int $i\n`;
    }
    
    void print(uint64 u) {
        cout `uint $u\n`;
    }
    
    void print(String s) {
        cout `String $s\n`;
    }
}}

The compiler chooses a function using a two-pass process: the first pass 
attempts to find a match based on the argument types without any conversions.  
The second pass attempts to find a match applying conversions whenever 
possible.

The general order of resolution in both passes is:

-   search for a match in the current namespace by /order of definition/.
-   repeat the search in each of the parent namespaces.

So for example, if we called #print()# with a #uint64# parameter, the 
resolver would check the first #print#, then check the second print, find a 
match and use #print(uint64 u)#.  If we called it with an #int32# parameter, 
the resolver would try all three functions, and not find a match.  It would 
then repeat the search with conversion enabled and immediately match the first 
function, because #int32# can implicity convert to #int64#.

We mentioned searching across namespaces: functions can be defined in most 
block contexts, including within other functions:

{{
    void outer() {
        void inner(int i) {
            cout `in inner\n`;
        }
        
        inner(100);
    }
    
    # we can't call "inner() from here...
}}

If there were another function, "#inner(uint u)#" defined in the same scope as 
#outer()#, the resolver would consider #inner(int i)# prior to #inner(uint 
u)#.  It would be an error to define an #inner(int i)# inside outer, because 
this would hide the definition in the parent scope.

Note that it is currently an error to use instance variables from the outer 
function in the inner function:

{{
    void outer() { int a; int inner() { return a; } } # DOESN'T WORK
}}

Due to a bug in the compiler, this will result in a lot of LLVM optimization 
errors being output - try to avoid doing this.

Classes
-------

Classes are a feature of object oriented programming languages that combine a 
set of data variables with a set of special functions called "methods."  As a 
simple example of a class, consider the representation of an x, y grahics 
coordinate:

{{
    import crack.lang XWriter;
    import crack.io cout, XWFormatter;

    class Coord {
        int x, y;
        
        oper init(int x0, int y0) : x = x0, y = y0 {}
        oper init() {}

        void writeTo(XWriter out) {
            XWFormatter(out) `Coord($x, $y)`;
        }
    }
}}

This class has two "instance variables:" #x# and #y#.  These get bundled 
together in a package whenever we create an instance of the class.

XXX we can use instance variables in methods

The "oper init" syntax creates a /constructor/, which is a special function 
that gets called when an instance of the class is created.  The constructor 
performs basic initialization of all of the instance variables.  The second 
"oper init", the one without arguments, is called the "default constructor."  
As in C++, these get generated automatically if the class has no other defined 
constructors.  If the class does define constructors, and you want a default 
constructor, you have to specify one explicitly as we've done above.

We can create an instance of #Coord# like so:

{{
    c := Coord(3, 4);
}}

Alternately, we can use a more C-like syntax:

{{
    Coord c = {3, 4};
}}

Both of these are just different syntactic flavors of the same thing: in both 
cases we're defining a variable "c" that is a reference to a #Coord# object.  
The system initializes this variable by:

-   Allocating memory large enough to accomodate a Coord object.
-   calling the appropriate "oper init" function for the construction 
    arguments ("3, 4" in the examples above).
-   Assigning the address of the newly created #Coord# object to #c#.

Note that the all variables of class types are references - they behave very 
much like pointers in C.  So if we were to initialize one variable from 
another, both variables would refer to the same object:

{{
    c := Coord(3, 4);
    d := c;
    c.y = 5; # d.y is now also 5
}}

This is different from the way that the primitive types behave.  Primitive 
types are always passed "by value."  So:

{{
    c := 100;
    d := c;
    c = c + 1; # c is now 101, d is still 100
}}

Our #Coord# class also has a writeTo() method.  This allows us to implement 
the #writeTo()# method which controls how an Object is written using the 
back-tick operator.  For example:

{{
    cout `$(Coord(10, 20))\n`; # prints "Coord(10, 10)" to standard output.
}}

Constructors
''''''''''''

We mentioned the "oper init" functions earlier.  These are called 
constructors.  In Java and C++, constructors are defined using a function that 
looks like the class name.  In the interests of providing uniform syntax for 
all special methods, Crack uses the "oper" keyword to introduce overloaded 
operators and special methods, including the constructors and destructors.

Constructor definitions have some special syntax.  The return type can be 
omitted, and you can provide an /initializer list/ for member variables and 
base classes.

In the example above, we defined two constructors:

{{
    oper init(int x0, int y0) : x = x0, y = y0 {}
    oper init() {}
}}

In the first case, the initializer list initializes the x and y member 
variables from the arguments x0 and y0.  Note that the initializers are 
specified using assignment syntax: "x = x0" instead of the construction syntax 
that C++ would have used: "x(x0)".

The construction syntax can be used, too, but it has a different meaning.  
Construction syntax means "construct the variable with the given arguments."  
Assignment syntax means "initialize the variable from the given value."

So, for example, "x(x0)" would be equivalent to "x = int(x0)", which is 
perfectly legal.  The uses for these two types of syntax becomes more obvious 
when we deal with members that are themselves class instances.

For example, let's say that we want to define a line segment:

{{
    class LineSegment {
    
        # two coordinates
        Coord c0, c1;
        
        ## Construct from two coordinates.
        oper init(Coord initC0, Coord initC1) : 
            c0 = initC0,  
            c1 = initC1 {
        }
        
        ## Construct from raw x and y values
        oper init(int x0, int y0, int x1, int y1) :
            c0(x0, y0),
            c1(x1, y1) {
        }
    }
}}

In the first constructor, we're using the assignment syntax because we want to 
bind the objects passed in (#initC0# and #initC1#) to the c0 and c1 variables. 
If we had instead used construction syntax:

{{
    oper init(Coord initC0, Coord initC1) : 
        c0(initC0),  
        c1{initC1) {
    }
}}

The compiler would have tried to find a #Coord# constructor that accepts 
another #Coord# object as an argument.  Since there is no such constructor, we 
would have gotten an error.  We could have instead done this:

{{
    oper init(Coord initC0, Coord initC1) : 
        c0(initC0.x, initC0.y),  
        c1(initC1.x, initC1.y) {
    }
}}

This would have called the two argument constructors and created two new 
#Coord# objects for c0 and c1.  There's an important difference between this 
and the assignment syntax we started with: with the assignment syntax, c0 and 
c1 become references to the objects that were passed into them.  If we did 
this:

{{
    Coord c0 = {10, 10}, c1 = {20, 20};
    ls := LineSegment(c0, c1);
    c0.x = 20;  # l.c0.x is now also 20.
}}

changing #c0.x# in this case also changes the value within #ls$ 
because the #ls#'s #c0# is the same object as the caller's #c0#.
If we had instead using the construction syntax, #ls# would have had its own 
copies of the #Coord# objects, and changing #c0#'s #x# value wouldn't have had 
any effect on #ls#.

If you don't specify an initializer for one of your instance variables, the 
constructor will initialize the variable based on whatever initializers you 
gave it in the instance variable definition.  So, for example, if we wanted 
coordinates to default to "-1, -1" for some reason, we could have done this:

class Coord {
    int x = -1, y = -1;
}

As with ordinary variables, the default constructors is used if no 
initializers are specified.

Initializers are not necessarily run in the order that you specify them: they 
are run in the order of member definition.  So in our examples above, if we 
had specified an initializer list of "#: y = y0, x = x0#", #x# still would 
have been initialized first.

You can define as many constructors as you want as long as their arguments 
have different types.  This is another example of overloading: the compiler 
can tell the difference between them from their argument types.

The /default constructor/ is the constructor without any arguments.  If you 
don't define any constructors in your class, the compiler will attempt to 
generate a default constructor for you - it will generate a constructor that 
initializes the members with their variable initializers, using their default 
constructors if there were no initializers.

Inheritence
'''''''''''

One important property of object-oriented programming languages is 
/inheritence/:  the ability to create a new class by extending an existing 
class.  Crack supports inheritence with a syntax similar to that of C++.  
Let's say that we wanted a coordinate like in our last example, only we also 
wanted it to have a name.  We could create a new class for this:

{{
    class NamedCoord {
        int x, y;
        String name;
    }
}}

but then we'd have to write everything that we wanted to reuse over again in 
the new class.  And everytime we fixed a bug in #Coord#, we'd have to fix the 
same bug in #NamedCoord#.  Inheritence provides a better way to do reuse code:

{{
    class NamedCoord : Coord {
        
        String name;
        
        oper init(int x, int y, String name0) : Coord(x, y), name = name0 {}
        
        void writeTo(XWriter out) {
            XWFormatter(out) `NameCoord($x, $y)`;
        }
    }
}}

In the example above, we're creating a new class called #NamedCoord# that is 
derived from #Coord#.  It will inherit all of #Coord#'s instance variables and 
methods.  We call #Coord# #NamedCoord#'s /base class/.  #NamedCoord# is a 
/subclass/ or /derived class/ of #Coord#.

One of the first things we have to deal with is #Coord#'s constructor.  Note 
that in the new initializer list, we have an entry for the base class as well 
as for the #name# variable.  If we didn't specify a constructor, the compiler 
would have used the default constructor if there was one.

Like member initializers, base classs are initialized in the order in which 
they are defined.  All base class initializers are run before any of the 
instance variable initializers for the class.  Consider the following example:

{{

    import crack.io cout;
    
    class A {
        oper init(String name) { cout `initializing $name\n`; }
        oper init() {}
    }
    
    class B : A {
        A a1, a2;
        
        # the order of initializers is ignored.
        oper init() : a2('a2'), a1('a1'), A('base class') {}
    }
    
    # create a temporary instance of B, prints
    B();
}}

This will print the following:

{{
    initializing base class
    initializing a1
    initializing a2
}}

Going back to our #NamedCoord# example, we also defined another #writeTo()# 
method:

{{
    void writeTo(XWriter out) {
        XWFormatter(out) `NameCoord($x, $y)`;
    }
}}

We did this because #Coord#'s #writeTo()# method writes out "Coord($x, $y)".  
We want to write "NamedCoord($x, $y)".

XXX talk about how derived types match base class type parameters and how this 
is _not_ conversion.

Crack also supports /multiple inheritence/: you can have any number of base 
classes.  But beware - it is illegal to inherit from the same base class 
multiple times, and Crack 0.1 doesn't guard against this very well.  
Eventually, Crack will support this using virtual base classes like in C++.  
We'll talk more about multiple inheritence in the next section.

The Special Base Classes
''''''''''''''''''''''''

There are three "special" base classes in Crack:

-   #Object#
-   #VTableBase#
-   #FreeBase#

The first two are available from any Crack code, #FreeBase# must be explicitly 
imported from #crack.lang#.

#Object# is the default base class for all other classes.  If you don't 
specify any base classes, your class will implicitly be derived from #Object#
(that's not entirely true: there is a bootstrapping mode in which classes have 
no default base class, but that's another story).

#Object# supports a general set of functionality that is applicable
to most types, including:

-   Reference counting.
-   Boolean conversion.
-   Formatting.
-   Comparison operators.

#VTableBase# is the base class for all classes with a vtable, which is the 
implementation mechanism of virtual functions.  It is a special class that is 
defined by the compiler, and it has no special contents other than a hidden 
vtable pointer instance variable.

#Object# is derived from #VTableBase#, so by default most methods in #Object# 
and all of its derived classes are virtual.

#FreeBase# is a base class that can be used in cases where you don't want to 
be derived from #Object# (like when defining a class that mirrors a C 
structure).  #FreeBase# does not support virtual functions, memory management,
or anything you don't put into your derived class.  If you're going to use it, 
you should at minimum figure out how to deal with memory management.

-   the "is" operator
-   the "null" constant.

Reference Counting
------------------

Reference counting is a simple form of memory management.  Every object is 
assigned a /reference count/, which is essentially the number of other 
objects or variables referencing the object.  When a new reference is added, 
the reference count is increased.  When a reference is removed, the reference 
count is decreased.  When the reference count drops to zero, the destructor is
called and the object's memory is released.

Crack's reference counting mechanism is actually implemented in the language 
as part of the implementation of #Object# in the #crack.lang# module.  The 
compiler uses two special hooks - the "#oper bind#" and "#oper release#" 
methods - to notify an object of when a reference is being added (by calling 
"#oper bind#") and released (by calling "#oper release#").  These methods are 
implicitly non-virtual: they cannot be overriden by a derived class, do not 
make use of the vtable and therefore they can be safely applied to null 
pointers.

It is possible to implement the bind and release methods in classes derived 
from #FreeBase# or #VTableBase# to implement your own memory management.  For 
example, the #Wrapper# class in #crack.exp.bindings# uses it #oper release# to 
always free the #Wrapper# instance when it is released, allowing it to 
essentially exist in the scope in which it is defined.  Note that if you were 
to pass such an object out of that scope, the results would be undefined.

For efficiency, Crack does not bind and release every time you might expect: 
for one thing, objects passed as function arguments are not bound and released 
for the function call - we know that the external caller has a reference to 
these objects.  The called function can simply borrow them.

Crack also has the notion of "productive" and "non-productive" expressions.  A 
productive expression is one that produces a reference.  A non-productive 
expression simply borrows an existing reference.  Variable references are 
always non-productive.  Functions returning values are (almost) always 
productive.

The compiler will call #oper bind# when assigning a non-productive value to 
a reference, or when returning a non-productive value.  It will call "oper 
release" when a variable goes out of scope or when productive temporary value 
is cleaned up.  In general, temporaries get cleaned up at the end of the 
outermost expression.  For && and ||

There's one thing you need to be aware of about reference counting: the 
mechanism is susceptible to the problem of reference cycles - this is when an 
object directly or indirectly references itself.  When this happens, the 
entire cycle of objects can become unfreeable, resulting in a memory leak.  
This is because each object retains a reference from the last object in the 
sequence, so even when all external references are removed, none of the 
objects will drop to a reference count of zero.

There's currently no good way around this: you just have to be aware that if 
you create a reference that can introduce a cycle, you'll need to take certain 
remedial measures to avoid leaking the objects.  This is typically 
accomplished by breaking the cycles at some point, normally during the 
destruction of some external object that references the cycle without 
particpating in it.

XXX bindings