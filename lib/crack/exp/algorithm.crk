// Algorithms
// Copyright 2010-2011 Shannon Weyrick <weyrick@mozek.us>

## Base class version of quick-sort, can be applied to primitive arrays.
class QuickSortPrim[Elem] {

    @static
    void _swap(Elem A, uintz l, uintz r){
        temp := A[l];
        A[l] = A[r];
        A[r] = temp;
    }

    @static
    void _quickSort3(Elem A, uintz l, uintz r) {
        
        // this is based on a 3-partition version from a talk by Robert Sedgewick
        // and Jon Bentley
        // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf
        uintz i = l-1;
        uintz j = r;
        uintz p = l-1;
        uintz q = r; 

        if (r <= l)
            return;
        v := A[r];

        while (true) {
            while (A[++i] < v);
            while (v < A[--j]) 
                if (j == l) 
                    break;
            if (i >= j) 
                break;
            _swap(A, i,j);
            if (A[i] == v) { 
                p++; 
                _swap(A, p, i);
            }
            if (v == A[j]) { 
                q--; 
                _swap(A, j, q);
            }
        }

        _swap(A, i, r);
        j = i-1; 
        i = i+1;

        for (k := l; k < p; k++) {
            _swap(A, k, j);
            j--;
        }

        for (k := r-1; k > q; k--) {
            _swap(A, i, k);
            i++;
        }

        _quickSort3(A, l, j);
        _quickSort3(A, i, r);
    }

    @static
    void sort(Elem A, uintz count){
        _quickSort3(A, 0, count - 1);
    }

}

## Quick-sort.  SeqT must have [], []= and count()
class QuickSort[SeqT] : QuickSortPrim[SeqT] {
    @static
    void sort(SeqT A){
        _quickSort3(A, 0, A.count() - 1);
    }
}

## Insertion sort primitive.  Can be used on primitive arrays.
class InsertionSortPrim[Elem] {

    @static
    void _swap(Elem A, uintz l, uintz r){
        temp := A[l];
        A[l] = A[r];
        A[r] = temp;
    }


    @static
    void _insertionSort(Elem A, uintz count) {
        uintz j = 1;
        uintz i;
        while (j < count) {
            key := A[j];
            i = j-1;
            while (i >= 0 && A[i] > key) {
                _swap(A, i+1, i);
                i--;
            }
            A[i+1] = key;
            j++;
        }
    }

    @static
    void sort(Elem A, uintz count){
        _insertionSort(A, count);
    }
}

## Insertion sort.  Requires [], []= and count().
## Usage: typeof(seq).sort(seq);
class InsertionSort[SeqT] : InsertionSortPrim[SeqT] {
    @static void sort(SeqT A) {
        _insertionSort(A, A.count());
    }
}
