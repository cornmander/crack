# Copyright 2010 Google Inc.

import crack.lang cmp, die, free;
import crack.runtime random;
import crack.io cout, Formatter, FStr, StringFormatter;
import crack.cont.array Array;
import crack.cont.treemap TreeMap;
import crack.cont.list List, DList;
import crack.cont.hashmap HashMap;
import crack.cont.priorityqueue PriorityQueue;
import crack.exp.algorithm QuickSort;
@import crack.exp.ann define;

TreeMap[String, int] m = {};
m['first'] = 100;
m['second'] = 200;
m['third'] = 300;
m['fourth'] = 400;
if (m['first'] != 100 || m['second'] != 200)
    cout `failed TreeMap access\n`;

Array[String] sa = {};

for (item :in m) {
    StringFormatter fmt = {};
    fmt `$(item.key): $(item.val)`;
    sa.append(fmt.createString());
}

QuickSort[Array[String]].sort(sa);

# Now sa = [first: 100, fourth: 400, second: 200, third: 300]

if (sa[0] != 'first: 100' || sa[1] != 'fourth: 400')
    cout `string array or iteration failed\n`;

#  test subarray
sub := sa.subarray(1);
if (sub[1] != 'second: 200' || sub[2] != 'third: 300' || sub[0] != 'fourth: 400')
    cout `string array subarray  1 failed, got '$sub'\n`;

if (sub.count() != 3) 
   cout `string array subarray failed, length $(sub.count()) != 3\n`;

# 2 arguments: start, len
sub = sa.subarray(1, 1);
if (sub[0] != 'fourth: 400')
    cout `string array subarray 2 failed, got '$sub'\n`;

if (sub.count() != 1) 
   cout `string array subarray failed, length $(sub.count()) != 1\n`;

sub = sa.subarray(1);
if (sub[1] != 'second: 200' || sub[2] != 'third: 300' || sub[0] != 'fourth: 400')
    cout `string array subarray 3 failed, got '$sub'\n`;

# array slice
sub = sa.slice(1, 3);
if (sub.count() != 2) 
   cout `string array subarray failed, length $(sub.count()) != 3\n`;

if (sub[1] != 'second: 200' || sub[0] != 'fourth: 400')
    cout `string array slice 1 failed, got '$sub)'\n`;

sub = sa.slice(1, 2);
if (sub.count() != 1) 
   cout `string array slice failed, length $(sub.count()) != 2\n`;

if (sub[0] != 'fourth: 400')
    cout `string array slice 2 failed, got '$sub'\n`;



testA :=Array[String]!['bogus', 'test', 'array'];
if (testA[0] != 'bogus' || testA[1] != 'test' || testA[2] != 'array')
   cout `string array ! notation failed, got $testA\n`;

intA := Array[int]![1,2,3,4,5,6,7,8,9,0];
stringA := Array[String]!["bogus", "test", "string"];

intRepr:=FStr() `$intA`;
stringRepr:=FStr() `$stringA`;

if (intRepr != '[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]')
    cout `Array[int].writeTo failed\n`;
if (stringRepr != '[bogus, test, string]')
    cout `Array[String].writeTo failed\n`;

# test map/reduce/filter

int plus(int a){
    return a + 2;
}

int minus(int a){
    return a - 2;
}

bool gte10(int a){
    return a >= 10;
}

int sum(int a, int b){
    return a + b;
}

intA.map(plus);
if (intA != Array[int]![3, 4, 5, 6, 7, 8, 9, 10, 11, 2])
    cout `Array[int].map failed, got $intRepr\n`;
intB := intA.mapped(minus);

if (intB != Array[int]![1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
    cout `Array[int].mapped failed\n`;

intB = intA.sorted();
intA.sort();
if (intA != Array[int]![2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    cout `sorted intA failed, got $intA\n`;

if (intA != intB)
    cout `Array compare/sorted failed, got $intA != $intB\n`;

intB = intA.filtered(gte10);
if (intB != Array[int]![10, 11])
    cout `filter intA failed, got $intB\n`;

intSum := intA.reduce(sum);
if (intSum != 65)
    cout `reduce intA failed, got $intSum\n`;

# test String Array  map/reduce/filter
String plusString(String s){
    return s + "__END";
}

String appendString(String s, String t){
    return s + t;
}

bool filterString(String s){
    return s == "test";
}

stringB := stringA.sorted();
if (stringB != Array[String]!["bogus", "string", "test"])
    cout `Array[String] sort failed, got $stringB\n`;

stringC := stringB.mapped(plusString);
stringB.map(plusString);

if (stringB != Array[String]!["bogus__END", "string__END", "test__END"] || stringB != stringC)
    cout `Array[String] map failed, got $stringB\n`;

stringB = stringA.filtered(filterString);
stringC.filter(filterString);

if (stringB != Array[String]!["test"] || stringC != Array[String]![])
    cout `Array[String] filter failed, got $stringB and $stringC\n`;

rs := stringA.reduce(appendString);

if (rs != "bogusteststring")
    cout `Array[String] reduce failed, got $rs\n`;

if (1) {
    bool deleted;
    class Tracer { oper del() { deleted = true; } }
    if (1) {
        Array[Tracer] t = [Tracer()];
    }
    
    if (!deleted)
        cout `FAILED array cleanup\n`;
}

# test a second invocation (uses a different code path)
class Foo {}
Array[Foo];

@define concat(Type) {
    String concat(Type list) {
        StringFormatter result = {};
        for (x :in list)
            result `$x`;
        return result.createString();
    }
}

@concat(List[String]);

List[String] s = {};
s.append('1');
s.append('2');
if (concat(s) != '12' || s.count() != 2)
    cout `Failed List appends\n`;
s = List[String]();
s.pushHead('2');
s.pushHead('1');
if (concat(s) != '12' || s.count() != 2)
    cout `failed List pushHeads\n`;

s.popHead();
if (concat(s) != '2' || s.count() != 1)
    cout `failed List popHead\n`;
s.popHead();
if (concat(s) != '' || s.count() != 0)
    cout `failed List popHead on empty list\n`;
s = List[String]();
s.insert(0, 'first');
s.insert(1, 'last');
s.insert(1, 'middle');
if (concat(s) != 'firstmiddlelast' || s.count() != 3)
    cout `failed List inserts\n`;
s.delete(0);
if (concat(s) != 'middlelast' || s.count() != 2)
    cout `failed List delete of first elem\n`;
s.pushHead('first');
s.delete(1);
if (concat(s) != 'firstlast' || s.count() != 2)
    cout `failed List delete of middle elem\n`;
s.delete(1);
if (concat(s) != 'first' || s.count() != 1)
    cout `failed List delete of last elem\n`;

if (s[0] != 'first')
    cout `failed List [] access\n`;

@concat(DList[String]);

void checkDList(DList[String] list, String val, uint count, String message) {
    # make sure that the list is properly terminated
    revIter := list.iter(true);
    if (revIter.next())
        cout `$message: last element has non-null next\n`;

    # verify that the list looks the same forwards as backwards
    List[String] temp = {};
    for (revIter = list.iter(true); revIter; revIter.prev())
        temp.pushHead(revIter.elem());
    
    iter := list.iter();
    listIter := temp.iter();
    i := 0;
    while (iter && listIter) {
        
        if (iter.elem() != listIter.elem())
            cout `$message: reverse failure in node -$i, expected \
$(listIter.elem()), got $(iter.elem())\n`;
        
        ++i;
        listIter.next();
        iter.next();
    }
    
    # make sure the contents of the list from front to back are what we expect
    flat := concat(list);
    if (flat != val)
        cout `$message: incorrect contents, expected $val, got $flat\n`;
    if (count != list.count())
        cout `$message: incorrect count, expected $count, got \
$(list.count())\n`;
}

DList[String] dl = {};

dl.append('1');
dl.append('2');
checkDList(dl, '12', 2, 'Failed DList appends');

dl = DList[String]();
dl.pushHead('2');
dl.pushHead('1');
checkDList(dl, '12', 2, 'Failed DList pushHeads');

dl.popHead();
checkDList(dl, '2', 1, 'Failed DList popHead');
dl.popHead();
checkDList(dl, '', 0, 'Failed DList popHead on empty list');

dl = DList[String]();
dl.insert(0, 'first');
dl.insert(1, 'last');
dl.insert(1, 'middle');
checkDList(dl, 'firstmiddlelast', 3, 'failed DList inserts');

dl.delete(0);
checkDList(dl, 'middlelast', 2, 'failed DList delete of first elem');

dl.pushHead('first');
dl.delete(1);
checkDList(dl, 'firstlast', 2, 'failed DList delete of middle elem');
dl.delete(1);
checkDList(dl, 'first', 1, 'failed DList delete of last elem');
dl.delete(0);
checkDList(dl, '', 0, 'failed DList delete of only elem');

dl.append('elem');
checkDList(dl, 'elem', 1, 'failed DList append after deleting');
if (dl[0] != 'elem')
    cout `failed DList [] access\n`;

dl.append('elem2');
dl.popTail();
checkDList(dl, 'elem', 1, 'failed DList append after popTail');
dl.popTail();
checkDList(dl, '', 0, 'failed DList append after popTail of last elem');

dl = DList[String]();
dl.append('1');
dl.append('2');
iter := dl.iter();
dl.insert(iter, '0');
iter.next(); iter.next();
dl.insert(iter, '1.5');
checkDList(dl, '011.52', 4, 'failed DList iterator insert');
dl.delete(iter);
iter = dl.iter();
dl.delete(iter);
checkDList(dl, '12', 2, 'Failed DList iterator delete');
dl.delete(iter);
dl.delete(iter);
checkDList(dl, '', 0, 'Failed DList iterator delete of last elements');

hm := HashMap[String, int]();
for (int i = 0; i < 100; ++i) {
    key := FStr() `$i`;
    hm[key] = i;
}

for (int i = 0; i < 100; ++i) {
    key := FStr() `$i`;
    if (hm[key] != i)
        cout `FAILED hash key lookup for $key\n`;
    hm.delete(key);
}

if (hm.count() != 0)
    cout `FAILED hash key count after deletes\n`;

# fuzz test hash map
if (true) {
    HashMap[int, int] map = {};
    Array[int] a = {};
    int i;
    while (i < 10000) {
        action := random() % 3;
        if (action < 2) {
            # insert a new random value
            
            # find an unused key
            v := random();
            while (map.get(v))
                v = random();
    
#            cout `$i: adding $v\n`;
            map[v] = v;
            a.append(v);
        } else if (action == 2 && a.count()) {
            # delete key
            index := uint(random()) % a.count();
#            cout `$i: deleting a[$index]: $(a[index])\n`;
            map.delete(a[index]);
            a.delete(index);
        }

        map.checkConstraints();
        ++i;
        
        # iterate over the map
        int countedElems;
        for (x :in map)
            ++countedElems;
        if (countedElems != map.count())
            cout `FAILED counted a different number of elements in a map than\
expected\n`;
    }
}

# priority queue
PriorityQueue[int] pq = { };
pq.push(1);
pq.push(3);
pq.push(5);
pq.push(10);
pq.push(12);
pq.push(2);
pq.push(8);
if (pq.top() != 12)
    cout `priority queue top() fail\n`;
int a = pq.pop();
if (a != 12)
    cout `priority queue pop() fail\n`;
a = pq.pop();
if (a != 10)
    cout `priority queue pop() fail\n`;
a = pq.pop();
if (a != 8)
    cout `priority queue pop() fail\n`;
pq.push(50);
a = pq.pop();
if (a != 50)
    cout `priority queue pop() fail\n`;

PriorityQueue[int] pq2 = { };
if (pq2.pop())
    cout `null pq pop fail\n`;

class Job {
    int priority;
    oper init(int p): priority = p { }
    int cmp(Object other) {
        if (this is other || !other.isa(Job)) return 0;
        else {
            j := Job.cast(other);
            return (this.priority > j.priority) ? 1 : -1;
        }
    }
}
PriorityQueue[Job] pq3 = { };
pq3.push(Job(5));
pq3.push(Job(10));
pq3.push(Job(50));
pq3.push(Job(20));
if (pq3.count() != 4)
    cout `priority queue count() fail\n`;
j := pq3.pop();
if (j.priority != 50)
    cout `priority queue pop() fail (50)\n`;
j = pq3.pop();
if (j.priority != 20)
    cout `priority queue pop() fail (20)\n`;
j = pq3.pop();
if (j.priority != 10)
    cout `priority queue pop() fail (10)\n`;
j = pq3.pop();
if (j.priority != 5)
    cout `priority queue pop() fail (5)\n`;
j = pq3.pop();
if (j)
    cout `priority queue pop() fail (null)\n`;

cout `ok\n`;
