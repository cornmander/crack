
#!/usr/bin/crack
# Copyright 2010 Google Inc.

import crack.runtime abort, free, getLocation, strcpy, strlen, malloc, 
    memcpy, memcmp, memmove, registerHook, write, BAD_CAST_FUNC, 
    EXCEPTION_FRAME_FUNC, EXCEPTION_MATCH_FUNC, EXCEPTION_RELEASE_FUNC, 
    EXCEPTION_UNCAUGHT_FUNC;
@import crack._poormac define;

bool true = (1 == 1);
bool false = (1 == 0);

void _die(byteptr message) {
    puts(message);
    abort();
}

class Writer;

void _writeObject(Writer out);

## Base class for things that you don't want derived from object or VTableBase.
class FreeBase {};

## The Object base class.  Object provides the basic reference counting
## mechanism, and most user classes should be derived from it.
class Object : VTableBase {
    uint refCount;

    # have to declare these before "oper init" otherwise it won't generate a
    # bind in "oper new"
    oper bind();
    oper release();

    oper init() : refCount = 0 {
    }

    # delete virtual function
    oper del() {
        if (refCount) {
            _die("Object with non-zero ref count deleted!");
        }
    }

    oper bind() {
        if (!(this is null))
            refCount = refCount + 1;
    }

    oper release() {
        if (this is null)
            return;

        refCount = refCount - 1;
        if (refCount == 0) {
            this.oper del();
            free(this);
        }
    }

    bool isTrue() {
        return true;
    }

    ## Comparison function - returns a value < 0 if this < other, 0 if this is
    ## equal to other, > 0 if this > other.
    int cmp(Object other) {
        if (this is other) return 0; else return 1;
    }

    @final bool oper <(Object other) {
        return this is null ? !(other is null) : cmp(other) < 0;
    }

    @final bool oper <=(Object other) {
        return this is null ? true : cmp(other) <= 0;
    }

    @final bool oper ==(Object other) {
        return this is null ? other is null : cmp(other) == 0;
    }

    @final bool oper !=(Object other) {
        return this is null ? !(other is null) : cmp(other) != 0;
    }

    @final bool oper >=(Object other) {
        return this is null ? other is null : cmp(other) >= 0;
    }

    @final bool oper >(Object other) {
        return this is null ? false : cmp(other) > 0;
    }

    @final bool toBool() {
        if (this is null)
            return false;
        else
            return isTrue();
    }

    void writeTo(Writer writer) {
        _writeObject(writer);
    }
};

## Base class for interfaces - these are classes that are not derived from
## Object but must be mixed in with classes derived from Object.  You can use
## them to define a interfaces and functionality that a derived class must
## conform to without limiting the inheritence of the derived class.
##
## Unfortunately, this pattern only allows a single MixIn since you cannot
## inherit from the mixin class more than once.
##
## Derived classes must implement the getObject() method.
class MixIn : VTableBase {

    ## Returns the underlying Object of the concrete class derived from the
    ## mix-in.  This is used by our bind and release operators to allow
    ## mix-ins to work with Object's reference counting.
    Object getObject() {
        _die('MixIn.getObject() not implemented.');
        return null;
    }

    # defining bind and release here takes advantage of the fact that the
    # same final functions can be inherited from multiple ancestors.  This is
    # arguably a bug, but we're going to exploit it for now.

    oper bind() { if (!(this is null)) getObject().oper bind(); }
    oper release() { if (!(this is null)) getObject().oper release(); }
}

class Buffer;

class Writer : VTableBase {
    void write(Buffer data) {
        puts(this.class.name);
        _die("Writer.write() not implemented.");
    }

    ## Flush the contents of the buffer.
    void flush() {}

    # MixIn stuff
    Object getWriterObject() {
        _die('Writer.getWriterObject() not implemented.');
        return null;
    }
    oper bind() { if (!(this is null)) getWriterObject().oper bind(); }
    oper release() { if (!(this is null)) getWriterObject().oper release(); }
}

## The buffer base class containing a bytebuf and size.
class Buffer : Object {

    // buffer and size.
    uint size;
    byteptr buffer;

    oper init(byteptr buffer, uint size) : buffer = buffer, size = size {}

    bool isTrue() {
        return size;
    }

    bool isEmpty() {
        return (size == 0);
    }

    void writeTo(Writer writer) {
        writer.write(this);
    }

    byte oper [](uint index) {
        if (index >= size)
            _die('string index out of bounds');
        return buffer[index];
    }

    byte oper [](int index) {
        if (index < 0 || index >= size)
            _die('string index out of bounds');
        return buffer[uint(index)];
    }

    ## Override Object.cmp() to do buffer comparison.
    int cmp(Object other) {

        # deal with the simple case
        if (this is other)
            return 0;

        # if the other object is a string, do string comparison.
        if (other.class.isSubclass(Buffer)) {
            os := Buffer.unsafeCast(other);

            # if both strings are the same size, this is just a straight
            # memcmp().
            int rc;
            if (size == os.size) {
                return memcmp(buffer, os.buffer, size);

            # if one string is longer than the other, only compare the
            # common-sized substring and if those are equal, the longer one is
            # greater
            } else if (size > os.size) {
                rc = memcmp(buffer, os.buffer, os.size);
                if (!rc) rc = 1;
            } else {
                rc = memcmp(buffer, os.buffer, size);
                if (!rc) rc = -1;
            }
            return rc;
        } else {
            # if other is not a string, it is not equal.
            return 1;
        }
    }
}

void _writeObject(Writer out) {
    out.write(Buffer('<Object>', 8));
}

## A writable buffer.  You can assume that it is safe to write to one of these.
class WriteBuffer : Buffer {

    ## constructor inheritence would be nice
    oper init(byteptr buffer, uint size) : Buffer(buffer, size) {}

    ## Move data from an arbitrary byteptr into the buffer.
    void move(uint start, byteptr ptr, uint count) {
        if (start + count > size)
            _die('Move target out of bounds');
        memmove(buffer + start, ptr, count);
    }

    ## move data from one place in the buffer to another place in the buffer.
    void move(uint newStart, uint oldStart, uint count) {
        if (oldStart + count > size)
            _die('Move source out of bounds');
        move(newStart, buffer + oldStart, count);
    }

    ## move a buffer to a place in this buffer.
    void move(uint newStart, Buffer buf) {
        if (newStart + buf.size > size)
            _die('Move target out of bounds');
        move(newStart, buf.buffer, buf.size);
    }
};

## A managed buffer.  Deletes the bytebuf when it goes out of scope.
class ManagedBuffer : WriteBuffer {

    oper init(uint size) : WriteBuffer(malloc(size), size) {}

    ## Orphan's the byte buffer, returning it for use by the caller.  The
    ## caller is responsible for freeing it.
    byteptr orphan() {
        temp := buffer;
        buffer = null;
        size = 0;
        return temp;
    }

    ## Grow the buffer to the new size.
    void grow(uint newSize) {
        if (newSize <= size) {
            puts('attempt to grow to a smaller or same size.');
            abort();
        }

        newBuffer := malloc(newSize);
        if (!(buffer is null)) {
            memcpy(newBuffer, buffer, size);
            free(buffer);
        }
        buffer = newBuffer;
        size = newSize;
    }

    oper del() {
        if (!(buffer is null))
            free(buffer);
    }
};

## AppendBuffer lets you add stuff onto the end of it.
class AppendBuffer : ManagedBuffer {
    uint pos;

    oper init(uint size) : ManagedBuffer(size) {}

    ## Append a single byte to the buffer, growing if necessary.
    void append(byte c) {
        if (pos >= size)
            grow(size * 2);
        buffer[pos++] = c;
    }

    ## Extend the buffer with the (entire) other buffer.
    void extend(Buffer other) {
        uint newPos = pos + other.size;
        if (newPos > size)
            # grow to the larger of newPos and size * 2
            if (newPos > size * 2)
                grow(newPos);
            else
                grow(size * 2);
        move(pos, other);
        pos = newPos;
    }

    ## Extend the buffer with a portion of the other buffer.
    void extend(Buffer other, uint len) {
        if (len > other.size)
            _die('Extend length out of bounds');
        uint newPos = pos + len;
        if (newPos > size)
            # grow to the larger of newPos and size * 2
            if (newPos > size * 2)
                grow(newPos);
            else
                grow(size * 2);
        move(pos, other.buffer, len);
        pos = newPos;
    }

}

# substring forward declarations - we need the full array to support doing
# these efficiently

class SubString;
class String;
SubString _substr(SubString target, uint pos, uint len);
SubString substr(SubString target, int pos, uint len);
SubString substr(SubString target, int pos);
SubString slice(SubString target, int start, int end);
SubString slice(SubString target, int start);
SubString _substr(String target, uint pos, uint len);
SubString substr(String target, int pos, uint len);
SubString substr(String target, int pos);
SubString slice(String target, int start, int end);
SubString slice(String target, int start);
SubString rtrim(String target);

@define substr2 1 {

        # adjust a negative position
        if (pos < 0)
            pos = int($1.size) + pos;

        return _substr($1, uint(pos), len);
    }
$$

@define substr1 1 {

        # adjust a negative position
        if (pos < 0)
            pos = int($1.size) + pos;

        return _substr($1, uint(pos), $1.size - uint(pos));
    }
$$

@define slice2 1 {

        # adjust negative offsets
        if (start < 0)
            start = int($1.size) + start;
        if (end < 0)
            end = int($1.size) + end;

        # bounds checking
        if (end < start)
            _die('Start of slice is after end.');

        return _substr($1, uint(start), uint(end - start));
    }
$$

@define slice1 1 {

        # adjust negative offsets
        if (start < 0)
            start = int($1.size) + start;

        # bounds checking
        if (uint(start) > $1.size)
            _die('Start of slice is after end.');

        return _substr($1, uint(start), $1.size - uint(start));
    }
$$

## The string class.  Strings are immutable managed Buffer's - when they are
## deleted, their buffer goes away.
## The buffer is not guaranteed to be null-terminated, use CString if
## that's a requirement
class String : Buffer {

    ## Initialize from a buffer.  This copies the buffer, it does not assume
    ## ownership.
    oper init(Buffer buf) : Buffer(malloc(buf.size), buf.size) {
        memcpy(buffer, buf.buffer, buf.size);
    }

    ## Initialize from a WriteBuffer and optionally take ownership of the
    ## buffer.
    oper init(ManagedBuffer buf, bool takeOwnership) :
        Buffer(null, 0) {

        if (takeOwnership) {
            size = buf.size;
            buffer = buf.orphan();
        } else {
            size = buf.size;
            buffer = memcpy(malloc(buf.size), buf.buffer, buf.size);
        }
    }

    ## Initialize from a portion of a WriteBuffer and optionally take ownership
    ## of the buffer.
    oper init(ManagedBuffer buf, uint len, bool takeOwnership) :
        Buffer(null, 0) {

        if (takeOwnership) {
            ## NOTE if len < buf.size, the space is wasted.
            ## realloc if len << buf.size?
            size = len;
            buffer = buf.orphan();
        } else {
            size = len;
            buffer = memcpy(malloc(buf.size), buf.buffer, len);
        }
    }

    ## Initialize from a substring of buffer.  This copies the buffer from
    ## index pos to pos + len.  It does not assume ownership.
    oper init(Buffer buf, uint pos, uint len) : Buffer(malloc(len), len) {
        if (pos + len > buf.size)
            _die('out of bounds copy');
        memcpy(buffer, buf.buffer + pos, len);
    }

    ## Initialize from byte pointer and size and optionally take ownership.
    oper init(byteptr buf, uint size, bool takeOwnership) :
        Buffer(takeOwnership ? buf : memcpy(malloc(size), buf, size),
               size
               ) {
    }

    ## Initialize from a null-terminated c-string
    oper init(byteptr cString) : Buffer(null, strlen(cString)) {
        buffer = malloc(size + 1);
        strcpy(buffer, cString);
    }

    ## Create an empty string.
    oper init() : Buffer(malloc(0), 0) {}

    void _freeBuffer() {
        free(buffer);
    }

    oper del() {
        _freeBuffer();
    }

    ## Find the rightmost index of a character in a string, starting at
    ## index idx
    ## returns -1 if not found
    int rfind(byte c, uint idx) {
        if (idx >= size)
            return -1;
        for (uint i = idx; i != 0; i--) {
            if (buffer[i] == c)
                return int(i); // warning, possible truncate
        }
        if (buffer[0] == c)
            return 0;
        else
            return -1;
    }
    ## Find the rightmost index of a character in a string
    ## returns -1 if not found
    ## note this function is not safe for strings larger than INT_MAX
    int rfind(byte c) {
        if (size == 0)
            return -1;
        else
            return rfind(c, size-1);
    }

    ## Find the leftmost index of a character in a string, starting at
    ## index idx
    ## returns -1 if not found
    int lfind(byte c, uint idx) {
        if (idx >= size)
            return -1;
        for (uint i = idx; i < size; i++) {
            if (buffer[i] == c)
                return int(i); // warning, possible truncate
        }
        return -1;
    }
    ## Find the leftmost index of a character in a string
    ## returns -1 if not found
    ## note this function is not safe for strings larger than INT_MAX
    int lfind(byte c) {
        if (size == 0)
            return -1;
        else
            return lfind(c, 0);
    }


    ## Concatenation
    String oper +(String rhs) {
        uint newBufferSize = this.size + rhs.size;
        byteptr newRawBuffer = malloc(newBufferSize);
        memcpy(newRawBuffer, this.buffer, this.size);
        memcpy(newRawBuffer+this.size, rhs.buffer, rhs.size);
        return String(newRawBuffer, newBufferSize, true);
    }

    # note, not binary safe
    String oper +(byteptr rhs) {
        uint rhs_size = strlen(rhs);
        uint newBufferSize = size + rhs_size;
        byteptr newRawBuffer = malloc(newBufferSize);
        memcpy(newRawBuffer, buffer, size);
        memcpy(newRawBuffer + size, rhs, rhs_size);
        return String(newRawBuffer, newBufferSize, true);
    }

    ## Create a substring.  This function is smart enough to know if the
    ## receiver is already a SubString, in which case it will translate to
    ## the underlying String to avoid creating a stack of SubStrings.
    ## If 'pos' is negative, it is an offset from the end of the string.
    SubString substr(int pos, uint len) @substr2 this

    ## Create a substring from 'pos' to the end of the string.
    SubString substr(int pos) @substr1 this

    ## Slice is similar to substr, except that it accepts a start and end
    ## position (instead of a start position and length).  Both the start
    ## and end positions can be negative, indicating that they are relative
    ## to the end of the string.
    SubString slice(int start, int end) @slice2 this

    # Another variation on slice(), this gives a slice from 'start' to the
    # end of the string.
    SubString slice(int start) @slice1 this

    ## Remove trailing newline from the end of the string
    SubString rtrim() { return rtrim(this); }

    ## Returns a legal source representation of the string.
    String getRepr() {
        AppendBuffer buf = {size + 2};

        buf.append(39); # "'"
        for (uint i = 0; i < size; ++i) {
            ch := buffer[i];
            if (ch < 32 || ch > 127 || ch == 39 || ch == 92) {
                buf.append(92); # '\'
                buf.append(48 + (ch >> 6));
                buf.append(48 + ((ch & 56) >> 3));
                buf.append(48 + (ch & 7));
            } else {
                buf.append(ch)
            }
        }
        buf.append(39);

        buf.size = buf.pos;
        return String(buf, true);
    }
};

## A substring of an existing string object.  Substrings are much
## lighter weight than full String objects because SubString doesn't manage
## its own buffer.  It references the buffer of its underlying String.
class SubString : String {
    String _rep = null;

    ## Create a stubstring 'target' starting from 'pos' and of length 'len'.
    oper init(String target, uint pos, uint len) :
        String(target.buffer + pos, len, true),
        _rep = target {
    }

    ## Create a substring from 'pos' to the end of the string.
    oper init(String target, uint pos) :
        String(target.buffer + pos, target.size - pos, true),
        _rep = target {
    }

    oper init(String target, byteptr buf, uint len) :
        String(buf, len, true),
        _rep = target {
    }

    # duplicate the substring/slice interface since we can do them more
    # efficiently here

    SubString substr(int pos, uint len) @substr2 this
    SubString substr(int pos) @substr1 this
    SubString slice(int start, int end) @slice2 this
    SubString slice(int start) @slice1 this

    void _freeBuffer() {}
}

SubString _substr(SubString target, uint pos, uint len) {
    # do bounds checking
    if (pos > target.size || pos + len > target.size)
        _die('Substring out of bounds');

    byteptr buf = target.buffer + uint(pos);
    return SubString(target._rep, buf, len);
}

SubString substr(SubString target, int pos, uint len) @substr2 target
SubString substr(SubString target, int pos) @substr1 target
SubString slice(SubString target, int start, int end) @slice2 target
SubString slice(SubString target, int start) @slice1 target

SubString _substr(String target, uint pos, uint len) {
    # do bounds checking
    if (pos > target.size || pos + len > target.size)
        _die('Substring out of bounds');

    byteptr buf = target.buffer + pos;
    if (target.class.isSubclass(SubString))
        target = SubString.cast(target)._rep;

    return SubString(target, buf, len);
}

SubString substr(String target, int pos, uint len) {
    # adjust a negative position
    if (pos < 0)
        pos = int(target.size) - pos;

    return _substr(target, uint(pos), len);
}

SubString substr(String target, int pos) {
    # adjust a negative position
    if (pos < 0)
        pos = int(target.size) - pos;

    return _substr(target, uint(pos), target.size - uint(pos));
}

SubString slice(String target, int start, int end) {

    # adjust negative offsets
    if (start < 0)
        start = int(target.size) + start;
    if (end < 0)
        end = int(target.size) + end;

    # bounds checking
    if (end < start)
        _die('Start of slice is after end.');

    return _substr(target, uint(start), uint(end - start));
}

SubString slice(String target, int start) {

    # adjust negative offsets
    if (start < 0)
        start = int(target.size) + start;

    # bounds checking
    if (uint(start) > target.size)
        _die('Start of slice is after end.');

    return _substr(target, uint(start), target.size - uint(start));
}

SubString rtrim(String target) {

    if (target.class.isSubclass(SubString))
        target = SubString.cast(target)._rep;

    len := target.size;

    // XXX currently this merely finds the leftmost newline and
    // returns a substring up to that point. it needs to work harder
    // to find other whitespace and ensure the substring it returns
    // doesn't leave any valid non whitespace characters off
    pos := target.lfind(10);
    if (pos != -1)
        len = uint(pos);

    return SubString(target, target.buffer, len);
}

## A string that is guaranteed to be null terminated. The trailing null is
## not included in the size of the string.
class CString : String {

    @final void __copy(byteptr buf, uint newSize) {
        size = newSize;
        buffer = malloc(size + 1);
        memcpy(buffer, buf, size);
        buffer[size] = 0;
    }

    oper init(Buffer buf) {
        __copy(buf.buffer, buf.size);
    }

    oper init(SubString str) {
        __copy(str.buffer, str.size);
    }

    ## Initialize a the string from byteptr and size, take ownership of the
    ## memory if requested.
    ## If takeOwnership is true, buf[size] must be null.  This constructor
    ## will not verify that this is the case.
    oper init(byteptr buf, uint size, bool takeOwnership) :
        String(buf, size, true) {
        if (!takeOwnership)
            __copy(buf, size);
    }

    ## Initialize from a null-terminated byteptr, take ownership of the
    ## memory if requested.
    oper init(byteptr buf, bool takeOwnership) :
        String(buf, strlen(buf) + 1, takeOwnership) {
        --size;
    }

}

class StaticString : String {

    oper init(byteptr data, uint size) : String(data, size, true) {}

    ## Initialize from a null terminated string.
    oper init(byteptr data) : String(data, strlen(data), true) {}

    # override _freeBuffer so we don't...
    void _freeBuffer() {}
};

class StackFrame : Object {
    String func, file;
    uint lineNumber;
    
    oper init(String func, String file, uint lineNumber) :
        func = func,
        file = file,
        lineNumber = lineNumber {
    }
}

## Base exception class.
class Exception : Object {
    String text;
    array[StackFrame] __stackTrace = array[StackFrame](16);
    uint __stackTraceSize = 0, __stackTraceCap = 16;

    oper init(String text) : text = text {}
    
    oper del() {
        for (int i; i < __stackTraceSize; ++i)
            __stackTrace[i].oper release();
        free(__stackTrace);
    }
    
    void append(StackFrame frame) {
        if (__stackTraceSize == __stackTraceCap) {
            
            # out of room, reallocate.
            __stackTraceCap *= 2;
            temp := array[StackFrame](__stackTraceCap);
            
            # move everything to the new array
            for (int i; i < __stackTraceSize; ++i)
                temp[i] = __stackTrace[i];
            free(__stackTrace);
            __stackTrace = temp;
        }
        
        __stackTrace[__stackTraceSize++] = frame;
        frame.oper bind();
    }
    
    void writeTo(Writer out) {
        for (int i = int(__stackTraceSize - 1); i >= 0; --i) {
            out.write(__stackTrace[i].func);
            out.write(StaticString('\n'));
        }
        out.write(StaticString(this.class.name));
        out.write(StaticString(': '));
        out.write(text);
        out.write(StaticString('\n'));
    }
}

class BadCastError : Exception {
    oper init(String text) : Exception(text) {}
}

bool exceptionMatchFunc(Class classObj, Object obj) {
    return obj.class.isSubclass(classObj);
}

void badClassFunc(Class curType, Class newType) {
    throw BadCastError(String('Unable to cast object of type ') + 
                        curType.name + 
                        ' to ' + newType.name
                       );
}

void exceptionReleaseFunc(Object ex) {
    ex.oper release();
}

void exceptionFrameFunc(Object ex, voidptr last_ip) {
    if (ex.class.isSubclass(Exception)) {
        e := Exception.cast(ex);
        
        info := array[byteptr](3);
        getLocation(last_ip, info);
        
        e.append(StackFrame(StaticString(info[0]), StaticString(info[1]), 
                            uint(uint64(info[2]))
                            )
                 );
    }
}

## gets called at the toplevel exception handler when an exception is not 
## caught
void uncaughtExceptionHandler(Object ex) {
    class StdErr : Object, Writer {
        void write(Buffer buf) { write(2, buf.buffer, buf.size); }
        void write(byteptr string) { write(2, string, strlen(string)); }
        Object getWriterObject() { return this; }
    }

    # this can run after cleanups, so we can't use cerr here...
    writer := StdErr();
    writer.write('Uncaught Exception:\n');
    if (ex.class.isSubclass(Exception)) {
        Exception.cast(ex).writeTo(writer);
    } else {
        writer.write('  ');
        writer.write(StaticString(ex.class.name));
        writer.write('\n');
    }
}

registerHook(EXCEPTION_MATCH_FUNC, exceptionMatchFunc);
registerHook(BAD_CAST_FUNC, badClassFunc);
registerHook(EXCEPTION_RELEASE_FUNC, exceptionReleaseFunc);
registerHook(EXCEPTION_FRAME_FUNC, exceptionFrameFunc);
registerHook(EXCEPTION_UNCAUGHT_FUNC, uncaughtExceptionHandler);

# misc functions

void print(String val) {
    puts(val.buffer);
}

void print(StaticString val) {
    puts(val.buffer);
}

void puts(StaticString val) {
    puts(val.buffer);
}

void print(CString val) {
    puts(val.buffer);
}

void die(String message) {
    print(message);
    abort();
}

void die() {
    abort();
}

# comparison functions (helpful for macros)
int cmp(Object a, Object b) {
    if (a is b)
        return 0;
    else if (a)
        return a.cmp(b);
    else if (b)
        return -1;
    else
        return 1;
}

@define lightcmp 1 int cmp($1 a, $1 b) { return a - b; } $$
@define heavycmp 1 int cmp($1 a, $1 b) {
    if (a > b)
        return 1;
    else if (a < b)
        return -1;
    else
        return 0;
}

$$

@lightcmp byte
@lightcmp int32
@heavycmp uint32
@heavycmp int64
@heavycmp uint64
@heavycmp float32
@heavycmp float64

