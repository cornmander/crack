# Copyright 2011 Google Inc
# Generic hash map implementation

import crack.lang makeHashVal, free, AssertionError, KeyError, Formatter;
import crack.io cout, StandardFormatter, FStr, Writer;

class HashMap[Key, Value] {
    class Item {
        uint _hash;
        Key key;
        Value val;
        
        oper init(uint hash, Key key, Value val) :
            _hash = hash,
            key = key,
            val = val {
        }
    }
    
    array[Item] _items;
    uint _size, _cap;
    
    class Iter {
        HashMap __map;
        int __index = -1;

        @final void next();
        
        oper init(HashMap map) : __map = map { next(); }
        
        @final Item elem() { return __map._items[__index]; }
        
        @final void next() {
            while ((++__index < __map._cap) && 
                   (!__map._items[__index]))
                ;
        }
        
        bool isTrue() { return __index < __map._cap; }
    }
    
    oper init() : _items(16), _cap = 16 {}
    
    @final
    void _free(){
        # release all items
        for (int i = 0; i < _cap; ++i)
            if (_items[i])
                _items[i].oper release();
        
        # free the list
        free(_items);
    }
    
    @final
    void clear(uint newcap) {
        _free();
        _items = array[Item](newcap);
        _cap = newcap;
        _size = 0;
    }
    
    @final
    void clear() {
        clear(16);
    }
    
    oper del() {
        _free();
    }
    
    @final int __findSlot(uint hash, Key key) {
        
        # find the ideal slot
        i := hash % _cap;
        
        # if it's occupied by something with a different key, increment to 
        # the next slot.
        while (_items[i] && _items[i].key != key) {
#            cout `desired slot $i for $key is occupied,`;
            i = (i + 1) % _cap;
#            cout `checking slot $i\n`;
        }
#        cout `assigning $key to $i\n`;
        
        return int(i);
    }
    
    @final void __reallocate() {
        
        # stash the old array, create a new array with double the capacity.
        oldCap := _cap;
        _cap = oldCap * 2;
        array[Item] oldItems = _items;
        _items = array[Item](_cap);
        
        # move everything over to the new array.
        for (uint i = 0; i < oldCap; ++i) {
            item := oldItems[i];
            if (item)
                _items[__findSlot(item._hash, item.key)] = item;
        }
        
        # free the old list
        free(oldItems);
    }
    
    Value set(Key key, Value val) {
#        cout `*** map[$key] = $val\n`;
        hash := makeHashVal(key);
        i := __findSlot(hash, key);
        if (_items[i]) {
            # slot is occupied, simply replace the value
#            cout `replacing $key at $i with $val\n`;
            _items[i].val = val;
        } else {
            # see if we've exceeded capacity
            if (_size > 3 * _cap / 4) {
#                cout `reallocating\n`;
                __reallocate();
                i = __findSlot(hash, key);
            }
            
            item := Item(hash, key, val);
#            cout `storing key $key at $i with $val\n`;
            _items[i] = item;
            item.oper bind();
            ++_size;
        }
        
        return val;
    }

    Value oper []=(Key key, Value val) {
        return set(key, val);
    }

    ## Returns true if the key exists
    bool contains(Key key) {
        hash := makeHashVal(key);
        i := __findSlot(hash, key);
        return _items[i];
    }

    ## Returns the value associated with the specified key, throws KeyError if 
    ## the key is not in the container.
    Value oper [](Key key) {
        hash := makeHashVal(key);
        i := __findSlot(hash, key);
        if (_items[i])
            return _items[i].val;
        else
            throw KeyError(FStr() `Invalid key: $key`);
    }

    ## Returns the value associated with the specified key, null if the key is 
    ## not in the container.
    Value get(Key key) {
        hash := makeHashVal(key);
        i := __findSlot(hash, key);
        return _items[i] ? _items[i].val : null;
    }
    
    ## Returns the value associated with the key, 'default' if the key is not 
    ## in the container.
    Value get(Key key, Value default) {
        hash := makeHashVal(key);
        i := __findSlot(hash, key);
        return _items[i] ? _items[i].val : default;
    }
    
    # Check all subsequent slots up to the next empty slot to see if there are 
    # any items that would like to fill 'index'
    # Returns 'true if it found a replacement.
    bool __findNewOccupant2(int index) {
        bool foundReplacement;
        last := index;
        i := int((index + 1) % _cap);
        while (_items[i]) {
            if (_items[i]._hash % _cap == index) {
#                cout `moving $(_items[i].key) which wants to be in $index \
#to $last\n`;
                _items[last] = _items[i];
                _items[i] = null;
                foundReplacement = true;
                
                # first see if there's an item that wants to be in the newly
                # opened slot.
                if (__findNewOccupant2(i))
                    # there was, and we know that the recursive call has left 
                    # us with a safe contiguous block of items, so we're done.
                    break;
                else
                    # There is not.  See if there's an item that wants to be 
                    # in the originally opened slot, if so move it to this 
                    # slot.
                    last = i;
            }
            i = int((i + 1) % _cap);
        }
        
        return foundReplacement;
    }
    
    void __findNewOccupant3(int opening) {
        
        # scan through the continguous following items to see if there are any 
        # that don't belong where they are and would be better served by the 
        # newly opened position.  
        # We do some funny math here - basically we want to be able to ask 
        # the question "would the item at 'i' be better off at slot 
        # 'opening'"  We can phrase this question concisely as 
        # "desiredIndex(item) <= 'opening'" if we offset all indeces by the 
        # container capacity and reserve the use of the 'actualIndex' computed 
        # from the modulus to the places where we're actually referencing the 
        # item.  So in this function, we use the variables:
        #  index: the index under consideration offset by the array capacity
        #  actualIndex: 
        
        # (we defer the modulus operation so we can 
        # make this determination with a simple '<=' check)
        i := opening + 1;
        
        while (_items[i]) {
#            cout `does $(_items[i].key) at $i which wants to be at \
# $(_items[i]._hash % _cap) belong at $opening?\n`;
#            cout `  opening = $opening, $(_items[i]._hash % _cap <= 
#                                          opening)\n`;
            if (_items[i]._hash % _cap <= opening) {
                # found one!
#                cout `moving $(_items[i].key) which wants to be in $opening \
#to $opening\n`;
                i = int(i % _cap);
                _items[opening] = _items[i];
                _items[i] = null;
                
                # repeat with the newly vacated opening
                opening = i;
            }
            ++i;
        }
    }

    void __findNewOccupant(int opening) {
        
        # check if a < b <= c, respecting the modulus operation.
        bool inOrder(int a, int b, int c) {
            return 
                # if a < c, this is trivial
                a < c && a < b && b <= c ||
                
                # if a > c, the range is split between a..top of range and
                # bottom of range .. c
                   a > c && (b > a || b <= c);
        }
        
        # scan through the continguous following items to see if there are any 
        # that don't belong where they are and would be better served by the 
        # newly opened position.  
        # make this determination with a simple '<=' check)
        i := int((opening + 1) % _cap);
        
        # find the last open slot
        last := opening ? opening - 1 : int(_cap - 1);
        while (_items[last])
            if (--last < 0) last = int(_cap + last);
        
        while (_items[i]) {
            desired := int(_items[i]._hash % _cap);
#            cout `does $(_items[i].key) at $i which wants to be at \
# $desired belong at $opening (last = $last)?\n`;
            if (inOrder(last, desired, opening)) {
                # found one!
#                cout `moving $(_items[i].key) to $opening\n`;
                _items[opening] = _items[i];
                _items[i] = null;
                
                # repeat with the newly vacated opening
                opening = i;
            }
            i = int((i + 1) % _cap);
        }
    }
    
    void delete(Key key) {
        hash := makeHashVal(key);
        i := __findSlot(hash, key);
        if (_items[i]) {
#            cout `deleting item $key at $i\n`;
            _items[i].oper release();
            _items[i] = null;
            --_size;
            __findNewOccupant(i);
        } else {
            throw KeyError(FStr() `Invalid key: $key`);
        }
    }

    Iter iter() { return Iter(this); }

    void writeTo(Formatter fmt) {
        fmt.format(fmt.MAPSTART);
        bool first = true;
        for (item :in this){
            if (!first) fmt.format(fmt.ELEMSEP);
            else first = false;
            fmt.format(item.key);
            fmt.format(fmt.KEYVALSEP);
            fmt.format(item.val);
        }
        fmt.format(fmt.MAPEND);
    }

    uint count() {
        return _size;
    }
    
    ## A HashMap is true if it has elements.
    bool isTrue() { return _size; }
    
    ## Method for testing - verify that all constraints are satisfied.
    void checkConstraints() {
        for (int i = 0; i < _cap; ++i) {
            if (_items[i]) {
                expected := _items[i]._hash % _cap;
                if (expected != i) {
                    # make sure there are no empty slots between here and the
                    # expected index
                    int j = i;
                    while (true) {
                        if (!_items[j])
                            throw AssertionError(FStr() `Empty slot at $j \
between actual position of $(_items[i].key) at $i and expected position at \
$expected`);
                        if (j == expected)
                            break;
                        --j;
                        if (j < 0)
                            j = int(_cap + j);
                    }
                }
            }
        }
    }
}

