// Binding of libm
// Copyright (C) 2010 Conrad D. Steenberg
// Lincensed under LGPLv3

// See http://anubis.dkuug.dk/jtc1/sc22/wg14/www/docs/n869/ for libm reference
// As a general rule, follow libm as well as GSL, without copying code.
// For vector and matrix functions, try to stay close to numpy

// import functions and some constants known at compile time
@import crack._poormac define;
import crack.runtime sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, asinh,
                    acosh, atanh, atoi, atof, strtof, usecs, exp, exp2,
                    ilogb, log, log10, log1p, log2, cbrt, abs, hypot,  sqrt,
                    erf, erfc, lgamma, tgamma, ceil, floor, nearbyint, rint,
                    round, trunc, fpclassify, isfinite, isinf, isnan,
                    isnormal, sign, fmod, remainder, copysign, nextafter,
                    dim, pow, testexcept, clearexcept, errno, setErrno, 
                    HUGE_VAL, INFINITY, NAN, FP_INFINITE, FP_NAN,
                    FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_ILOGB0, FP_ILOGBNAN,
                    ALL_EXCEPT, INVALID, DIVBYZERO, OVERFLOW,
                    UNDERFLOW, ERANGE;

// Calculated using GSL, double precision
float E =            2.7182818284590452354;   // e
float LOG2E =        1.4426950408889634074;   // base 2 log of e
float LOG10E =       0.43429448190325182765;  // base log of e
float LN2 =          0.69314718055994530942;  // base e log of 2
float LN10 =         2.30258509299404568402;  // base e log of 10
float LNPI =         1.14472988584940017414;  // ln(pi)
float PI =           3.14159265358979323846;  // pi
float PI_2 =         1.57079632679489661923;  // pi/2
float PI_4 =         0.78539816339744830962;  // pi/4
float PI1 =          0.31830988618379067154;  // 1/pi
float PI2 =          0.63661977236758134308;  // 2/pi
float SQRTPI2 =      1.12837916709551257390;  // 2/sqrt(pi)
float SQRT2 =        1.41421356237309504880;  // sqrt(2)
float SQRT3 =        1.73205080756887729353;  // sqrt(3)
float SQRT1_2 =      0.70710678118654752440;  // 1/sqrt(2)
float SQRTPI =       1.77245385090551602730;  // sqrt(pi)
float GAMMA =        0.57721566490153286061;  // Euler's constant gamma

// A few simple functions, overlaoded with various types
// Generics really helps here
@define _max 1
int max($1 v1, $1 v2){
  if (v1>v2) return v1;
  return v2;
}
@@

@_max int32
@_max uint32
@_max float32
@_max int64
@_max uint64
@_max float64

@define _min 1
int min($1 v1, $1 v2){
  if (v1>v2) return v1;
  return v2;
}
@@

@_min int32
@_min uint32
@_min float32
@_min int64
@_min uint64
@_min float64

// Augment the atoi(char*) imported from _math
@define _atoi
int atoi($1 s){
  return atoi(s.buffer);
}
@@

_atoi StaticString
_atoi String
_atoi CString

// Augment the atof(char*) imported from _math
@define _atof
float atof($1 s){
  return atof(s.buffer);
}
@@

_atof StaticString
_atof String
_atof CString
