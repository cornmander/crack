#!/usr/local/bin/crack

import crack.lang die, FreeBase, free;
import crack.io cout;
import crack.exp.bindings ArgcWrapper, IntWrapper, Opaque;
import "libgtk-x11-2.0.so"
    gtk_box_pack_start,
    gtk_button_new_with_label,
    gtk_container_add,
    gtk_editable_set_editable,
    gtk_editable_select_region,
    gtk_entry_get_text,
    gtk_entry_new,
    gtk_entry_set_text,
    gtk_entry_set_visibility,
    gtk_hbox_new,
    gtk_label_new,
    gtk_tooltips_new,
    gtk_tooltips_set_tip,
    gtk_vbox_new,
    g_print, 
    gtk_init, 
    gtk_main,
    gtk_main_quit, 
    gtk_widget_show,
    gtk_widget_destroy,
    gtk_window_new;
import "libgobject-2.0.so" g_list_append, g_signal_connect_data;
#import "./wrapper.so" Object_signalConnect, Object_crazy;
import "libc.so.6" printf;

class GtkWidget : Opaque {};
class GdkEvent : Opaque {};

class GList : FreeBase {
    voidptr data = null;
    GList next = null;
    GList prev = null;
};

GList g_list_append(GList list, voidptr data);
void g_print(byteptr b);
void gtk_init(voidptr argc, voidptr argv);
void gtk_widget_destroy(GtkWidget widget);
void gtk_widget_show(GtkWidget widget);
void gtk_main();
void gtk_main_quit();
void g_signal_connect_data(GtkWidget widget, byteptr signal, 
                           voidptr callback,
                           voidptr callbackArg,
                           voidptr destroy_data, # set to null
                           uint connect_flags    # set to zero
                           );

GtkWidget gtk_window_new(int val);
void gtk_box_pack_start(GtkWidget box, GtkWidget child, bool expand, 
                        bool fill,
                        uint padding
                        );
GtkWidget gtk_button_new_with_label(byteptr label);
void gtk_container_add(GtkWidget container, GtkWidget widget);
void gtk_editable_select_region(GtkWidget entry,
                                int start,
                                int end
                                );
void gtk_editable_set_editable(GtkWidget entry,
                               bool editable
                               );
byteptr gtk_entry_get_text(GtkWidget entry);
GtkWidget gtk_entry_new();
void gtk_entry_set_text(GtkWidget entry,
                        byteptr text
                        );
void gtk_entry_set_visibility(GtkWidget entry,
                              bool visible
                              );
GtkWidget gtk_hbox_new(bool homogenous, uint spacing);
GtkWidget gtk_label_new(byteptr text);
GtkWidget gtk_tooltips_new();
void gtk_tooltips_set_tip(GtkWidget tooltips,
                          GtkWidget widget,
                          byteptr tip_text,
                          byteptr tip_private
                          );
GtkWidget gtk_vbox_new(bool homogenous, uint spacing);

void hello(GtkWidget widget, byteptr data) {
    g_print("hello world\n".buffer);
}

bool delete_event(GtkWidget widget, GdkEvent event, byteptr data) {
    g_print('got delete event\n'.buffer);
    return true;
}

void destroy(GtkWidget widget, byteptr data) {
    gtk_main_quit();
}

# Wrapper classes - allow us to pass things like pointers to integers and 
# pointer to pointer to char * to C functions.

class List {
    GList _start = null;
    GList _end = null;
    
    void append(voidptr elem) {
        _start = g_list_append(_start, elem);
        if (_end is null) 1;
#            _end = _start;
    }
};

## window signal handlers.  Return true to abort futher processing.
class Handlers {
    bool onClicked() { return false; }
    bool onDestroy() { return false; }
};

bool _handleClicked(GtkWidget widget, Handlers handlers) {
    return handlers.onClicked();
}

bool _handleDestroy(GtkWidget widget, Handlers handlers) {
    cout `in handleDestroy\n`;
    if (handlers)
        return handlers.onDestroy();
    else
        return false;
}

class Widget : Handlers {
    GtkWidget _rep = null;
    Handlers __handlers = null;
    
    void setHandlers(Handlers handlers) {
        __handlers = handlers;
    }
    
    bool onClicked() {
        if (__handlers)
            return __handlers.onClicked();
        else
            return false;
    }

    void handleClicked() {
        g_signal_connect_data(_rep, 'clicked'.buffer, _handleClicked, 
                              this, 
                              null, 
                              0
                              );
    }

    bool onDestroy() {
        bool result = false;
        if (__handlers)
            result = __handlers.onDestroy();
        _rep = null;
        return result
    }

    oper init() {
        # connnect our destroy handler
        g_signal_connect_data(_rep, 'destroy'.buffer, _handleDestroy,
                              this, 
                              null, 
                              0
                              );
    }

    void show() {
        gtk_widget_show(_rep);
    }
    
    void destroy() {
        if (!(_rep is null)) {
            cout `destroying window\n`;
            gtk_widget_destroy(_rep);
        }
    }

    oper del() {
        destroy();
    }
    
};

class Container : Widget {
    void add(Widget child) {
        gtk_container_add(_rep, child._rep);
    }
};

class Toplevel : Container {
    oper init() {
        _rep = gtk_window_new(0);
    }
};

class Button : Widget {
    oper init(String label) {
        _rep = gtk_button_new_with_label(label.buffer);
    }
};

class Box : Container {
    void add(Widget child) {
        gtk_box_pack_start(_rep, child._rep, false, false, 0);
    }

    ## expand: if true, expand the box to fill the container, otherwise shrink 
    ##  to enclose the children.
    void add(Widget child, bool expand) {
        gtk_box_pack_start(_rep, child._rep, expand, false, 0);
    }

    ## fill: if true, expand the child, otherwise add padding.
    void add(Widget child, bool expand, bool fill) {
        gtk_box_pack_start(_rep, child._rep, expand, fill, 0);
    }

    ## padding: amount of padding added around each child.
    void add(Widget child, bool expand, bool fill, uint padding) {
        gtk_box_pack_start(_rep, child._rep, expand, fill, 0);
    }
    
};

class HBox : Box {
    oper init(bool homogeneous, uint spacing) {
        _rep = gtk_hbox_new(homogeneous, spacing);
    }
};

class VBox : Box {
    oper init(bool homogeneous, uint spacing) {
        _rep = gtk_vbox_new(homogeneous, spacing);
    }
};

class Label : Widget {
    oper init(String text) {
        _rep = gtk_label_new(text.buffer);
    }
};

class Tooltips : Widget {
    oper init() {
        _rep = gtk_tooltips_new();
    }
    
    void setTip(Widget widget, String text) {
        gtk_tooltips_set_tip(_rep, widget._rep, text.buffer, null);
    }
};

class Entry : Widget {
    oper init() {
        _rep = gtk_entry_new();
    }
    
    String getText() {
        return String(gtk_entry_get_text(_rep));
    }
    
    void setText(String text) {
        gtk_entry_set_text(_rep, text.buffer);
    }
    
    void setEditable(bool editable) {
        gtk_editable_set_editable(_rep, editable);
    }
    
    void setVisibility(bool visible) {
        gtk_entry_set_visibility(_rep, visible);
    }
    
    void selectRegion(int start, int end) {
        gtk_editable_select_region(_rep, start, end);
    }
};

class App {
    void init() {
        gtk_init(IntWrapper(1), ArgcWrapper('test'));
    }
    
    void main() {
        gtk_main();
    }
    
    void quit() {
        gtk_main_quit();
    }
};


# ----------------------- App code --------------------

