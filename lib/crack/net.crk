# Copyright 2010 Google Inc.

import crack.lang Buffer, FreeBase, WriteBuffer;
import crack.io Reader, Writer, Formatter, cout;
import crack.exp.error err, strerror;
import crack.container Array;
import crack.exp.bindings Opaque;
import crack.time TimeDelta;
import "libc.so.6" close, listen, send, socket, recv;
import "libcrack-runtime.so" 
    _crack_connect, 
    _crack_get_constants,
    _crack_make_ipv4,
    _crack_setsockopt_int,
    _crack_accept,
    _crack_bind,
    _crack_pollset_create,
    _crack_pollset_copy,
    _crack_pollset_destroy,
    _crack_pollset_set,
    _crack_pollset_get,
    _crack_pollset_next,
    _crack_poll,
    _crack_sigset_create,
    _crack_sigset_destroy,
    _crack_sigset_empty,
    _crack_sigset_fill,
    _crack_sigset_add,
    _crack_sigset_del,
    _crack_sigset_has;

int socket(int domain, int type, int protocol);
int close(int fd);
int listen(int fd, int backlog);
int send(int fd, byteptr buf, uint size, int flags);
int recv(int fd, byteptr buf, uint size, int flags);
uint32 _crack_make_ipv4(byte a, byte b, byte c, byte d);
int _crack_setsockopt_int(int fd, int level, int optval);

class _Constants : FreeBase {
    int AF_UNIX,
        AF_LOCAL,
        AF_INET,
        AF_INET6,
        AF_IPX,
        AF_NETLINK,
        AF_X25,
        AF_AX25,
        AF_ATMPVC,
        AF_APPLETALK,
        AF_PACKET,
        SOCK_STREAM,
        SOCK_DGRAM,
        SOCK_SEQPACKET,
        SOCK_RAW,
        SOCK_RDM,
        SOCK_PACKET,
        SOCK_NONBLOCK,
        SOCK_CLOEXEC,
        SOL_SOCKET,
        SO_REUSEADDR,
        POLLIN,
        POLLPRI,
        POLLOUT,
        POLLERR,
        POLLHUP,
        POLLNVAL;
    uint32 INADDR_ANY;
}
_Constants _crack_get_constants();
sockconsts := _crack_get_constants();

class SockAddr {}

class SockAddrIn : SockAddr {
    uint32 addr;
    uint port;
    
    oper init(byte a, byte b, byte c, byte d, uint port0) :
        addr = _crack_make_ipv4(a, b, c, d),
        port = port0 {
    }
    
    oper init(uint32 addr0, uint port0) : addr = addr0, port = port0 {}
    
    void writeTo(Writer out) {
        Formatter(out) `ip4:$addr:$port`;
    }
}

int _crack_connect(int s, SockAddrIn addr);
int _crack_accept(int s, SockAddrIn addr);
int _crack_bind(int s, SockAddrIn addr);

class PollFDs : Opaque {}

PollFDs _crack_pollset_create(uint size);
void _crack_pollset_destroy(PollFDs pollfds);
void _crack_pollset_copy(PollFDs dst, PollFDs src, uint size);
void _crack_pollset_set(PollFDs set, uint index, int fd, int events,
                        int revents
                        );

class SigSet : Opaque {}

SigSet _crack_sigset_create();
void _crack_sigset_destroy(SigSet sigmask);
int _crack_sigset_empty(SigSet sigmask);
int _crack_sigset_fill(SigSet sigmask);
int _crack_sigset_add(SigSet sigmask, int signum);
int _crack_sigset_del(SigSet sigmask, int signum);
int _crack_sigset_has(SigSet sigmask, int signum);

int _crack_poll(PollFDs fds, uint nfds, TimeDelta tv, SigSet sigmask);

## interface for all classes that can be polled.
class Pollable {
    int getFD() { err.do() `Pollable.getFD() not defined.`; return 0; }
}

class PollEvent {
    int fd, events, revents;
    Pollable pollable;
}

int _crack_pollset_next(PollFDs set, uint size, uint index,
                        PollEvent outputEntry
                        );

## Wrapper around a socket.
class Socket : Pollable, Reader, Writer {
    int fd;
    oper init(int domain, int type, int protocol) : 
        fd = socket(domain, type, protocol) {
    }
    
    oper init(int fd0) : fd = fd0 {}

    int getFD() { return fd; }

    void close() {
        close(fd);
        fd = -1;
    }
        
    oper del() {
        if (fd != -1)
            close();
    }
    
    ## Connect to the address.  Returns true on success, false on failure.
    bool connect(SockAddrIn addr) {
        return _crack_connect(fd, addr) == 0;
    }

    ## Bind to the address.  Returns true on success, false on failure.    
    bool bind(SockAddrIn addr) {
        return _crack_bind(fd, addr) == 0;
    }
    
    bool listen(int backlog) {
        return listen(fd, backlog) == 0;
    }
    
    bool setReuseAddr(bool val) {
        return _crack_setsockopt_int(fd, sockconsts.SOL_SOCKET,
                                     sockconsts.SO_REUSEADDR
                                     ) == 0;
    }
    
    int send(Buffer data, int flags) {
        return send(fd, data.buffer, data.size, flags);
    }

    int recv(WriteBuffer buf, int flags) {
        return recv(fd, buf.buffer, buf.size, flags);
    }

    class Accepted {
        Socket sock = null;
        SockAddr addr = null;
    
        oper init(Socket sock0, SockAddr addr0) :
            sock = sock0,
            addr = addr0 {
        }
    }
    
    ## Returns null if there was an error, errno should contain the error.
    Accepted accept() {
        SockAddrIn addr = {0, 0};
        rc := _crack_accept(fd, addr);
        if (rc == -1)
            return null;
        return Accepted(Socket(rc), addr);
    }
    
    void writeTo(Writer out) {
        Formatter(out) `Socket(fd: $fd)`;
    }
    
    # Reader interface
    uint read(WriteBuffer buffer) {
        rc := recv(buffer, 0);
        if (rc < 0)
            err.do() `Error writing to socket: $(strerror())`;
        return uint(rc);
    }
    
    Object getReaderObject() { return this; }
    
    # Writer interface
    void write(Buffer data) {
        rc := send(data, 0);
        if (rc < 0)
            err.do() `Error writing to socket: $(strerror())`;
        if (rc != data.size)
            err.do() `Incomplete write to socket`;
    }

    Object getWriterObject() { return this; }
}
        
## A poller is a collection of Pollables that you can use to wait for an event
## on any of the pollables and then iterate over the set of events that 
## occurred.
class Poller {
    Array __pollables;
    PollFDs __fds;
    uint __nextIndex;
    uint __capacity;
    int __iter;
    
    oper init() : 
        __pollables(256), 
        __fds = _crack_pollset_create(256),
        __capacity = 256 {
    }
    
    void grow(uint newCapacity) {
        if (newCapacity < __capacity)
            err.do() `cannot shrink`;
        
        __pollables.realloc(newCapacity);
        
        # create a new pollset and copy the existing one.
        newFDs := _crack_pollset_create(newCapacity);
        _crack_pollset_copy(newFDs, __fds, __capacity);

        __capacity = newCapacity;
    }

    void add(Pollable p, int events) {
        
        # grow if there's not enough space
        if (__nextIndex == __capacity) grow(__capacity * 2);
        
        # add it to the pollables and to the fds.
        __pollables.append(p);
        _crack_pollset_set(__fds, __nextIndex, p.getFD(), events, 0);
        
        ++__nextIndex;
    }

    ## Wait for up to timeout or until the next event.  'timeout' may be null, 
    ## in which case we wait indefinitely.
    ## Calling wait() resets the internal iterator - the next call to nx() 
    ## will return the first available event.
    ## Returns the number of sockets selected, -1 if there was an error.  0 if 
    ## there was a timeout.
    int wait(TimeDelta timeout) {
        __iter = 0;
        return _crack_poll(__fds, __nextIndex, timeout, null);
    }
    
    PollEvent nx() {
        if (__iter == -1)
            return null;

        PollEvent result;
        __iter = _crack_pollset_next(__fds, __nextIndex, uint(__iter), 
                                     result
                                     );
        
        if (__iter == -1)
            return null;
        
        # store the pollable in the result and return it.
        result.pollable = Pollable.cast(__pollables[uint(__iter++)]);
        return result;   
    }
}
