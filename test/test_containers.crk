# Copyright 2010 Google Inc.

import crack.sys exit;
import crack.lang free;
import crack.exp.error err;
import crack.io cout, Formatter, StringFormatter, Writer;
import crack.container Array, Container, DList, Iterator, KeyVal, List, TreeMap;
import crack.runtime random;

uint _ckseq(array[Object] ref, String context, Container cnt, Object a, 
            Object b, 
            Object c
            ) {
    # construct a reference array
    uint count;
    if (a is null) {
        count = 0;
    } else if (b is null) {
        count = 1;
        ref[0] = a;
    } else if (c is null) {
        count = 2;
        ref[0] = a;
        ref[1] = b;
    } else {
        count = 3;
        ref[0] = a;
        ref[1] = b;
        ref[2] = c;
    }
    // verify the count
    if (cnt.count() != count)
        err.do() `In $context: container count != $count: \
count = $(cnt.count()) $c`;
    
    i := cnt.iter();
    j := uint(0);
    while (i) {
        if (i.elem() != ref[j])
            err.do() `elem[$j] != $(ref[j]): elem = $(i.elem()), $cnt`;
        i.next();
        ++j;
    }
    return count;
}

void ckseq(String context, Container cnt, Object a, Object b, Object c) {
    ref := array[Object](3);
    _ckseq(ref, context, cnt, a, b, c);
    free(ref);
}

List list = {};
list.append('first');
list.append('second');
list.append('third');
list.insert(0, 'zeroth');
list.insert(4, 'fourth');
list.insert(3, '2.5');
list.insert(0, '-1');
list.insert(2, '0.5');
list.append('final');
list.delete(0);
list.delete(1);
list.delete(6);

if (list[0] != 'zeroth' || list[1] != 'first' || list[2] != 'second' ||
    list[3] != '2.5' || list[4] != 'third' || list[5] != 'fourth' ||
    list.count() != 6) {
    err.do() `$list is not \
        ['zeroth', 'first', 'second', '2.5', 'third', 'fourth']`;
}

# start fresh.
if (true) {
    list = List();
    list.insert(0, 'first');
    list.append('second');
    ckseq('List appends', list, 'first', 'second', null);
    
    list.delete(0);
    ckseq('List delete[0]', list, 'second', null, null);
    
    list.insert(0, 'first');
    ckseq('List insert to first', list, 'first', 'second', null);
    
    list.insert(1, 'middle');
    ckseq('List insert to middle', list, 'first', 'middle', 'second');
    
    list.delete(1);
    ckseq('List delete middle', list, 'first', 'second', null);
    
    list.append('third');
    list.delete(2);
    ckseq('List delete last', list, 'first', 'second', null);
    
    list.pushHead('zero');
    ckseq('List pushHead()', list, 'zero', 'first', 'second');
    elem := list.popHead();
    if (elem != 'zero')
        err.do() `List.popHead() returned $elem, expected 'zero'`;
    ckseq('List.popHead()', list, 'first', 'second', null);
}

void ckdl(String context, DList cnt, Object a, Object b, Object c) {
    ref := array[Object](3);
    count := _ckseq(ref, context, cnt, a, b, c);
    
    # now check backwards
    bi := cnt.bidiIter(true);
    while (bi.nx() && count) {
        --count;
        if (bi.elem() != ref[count])
            err.do() `elem[$count] != $(ref[count]): elem = $(bi.elem()), \
$cnt`;
    }
    
    if (bi)
        err.do() `reverse iter overflow: $cnt`;
}

# DList tests

DList dl = {};
dl.append('first');
dl.append('second');
ckdl('DList append', dl, 'first', 'second', null);

if (true) {
    List tmp = {};
    bi := dl.bidiIter(false);

    while (bi.nx())
        tmp.append(bi.elem());
    ckseq('BidiIterator traversal', tmp, 'first', 'second', null);

    bi = dl.bidiIter(true);
    tmp = List();
    while (bi) {
        tmp.append(bi.elem());
        bi.last();
    }
    ckseq('BidiIterator reverse traversal', tmp, 'second', 'first', null);
    
    i := dl.iter();
    i.next();
    dl.insert(i, 'middle');
    ckdl('Iterator insert inner', dl, 'first', 'middle', 'second');
    
    dl.delete(i);
    ckdl('Iterator delete inner', dl, 'first', 'second', null);
    
    i = dl.iter();
    dl.insert(i, 'zero');
    ckdl('Iterator insert head', dl, 'zero', 'first', 'second');
    dl.delete(i);
    if (i.elem() != 'first')
        err.do() `iterator not correctly positioned after delete`;
    
    dl.pushHead('zero');
    ckdl('dl.pushHead()', dl, 'zero', 'first', 'second');
    elem := dl.popHead();
    if (elem != 'zero')
        err.do() `popHead() returned $elem instead of "zero"`;
    ckdl('dl.popHead()', dl, 'first', 'second', null);
    
    dl.append('third');
    elem = dl.popTail();
    if (elem != 'third')
        err.do() `popTail() returned $elem instead of "third"`;
}

# memory leak test

if (true) {
    int deleteCount;
    class A {
        oper del() { ++deleteCount; }
    }
    
    dl = DList();
    dl.append(A());
    dl.append(A());
    dl = null;
    
    if (deleteCount != 2)
        err.do() `objects in DList not cleaned up: $deleteCount\n`;
}

# array tests

Array a1 = {3};
a1.append('first');
a1.append('second');
a1.append('xxx');
a1.append('fourth');
a1[2] = 'third';

if (a1[0] != 'first' || a1[1] != 'second' || a1[2] != 'third' ||
    a1[3] != 'fourth' || a1.count() != 4) {
    err.do() `$a1 is not ['first', 'second', 'third', 'fourth']`;
}

Array a2 = {};
a2.append('1');
a2.append('2');
if (a2[0] != '1' || a2[1] != '2' || a2.count() != 2) {
    err.do() `$a2 is not ['1', '2']`;
}

# set this to "cout" for debug info
Formatter out;

class Monitor {
    bool deleted;
}

class TestObj {
    Monitor mon;

    oper init(Monitor mon) : mon = mon {}

    oper del() {
        if (mon)
            mon.deleted = true;
    }
}

# array tests
arr := Array();
arr.append('first');
arr.append('second');
arr.append('third');
if (arr[0] != 'first')
    err.do() `arr[0] != "first"'`;
if (arr[1] != 'second')
    err.do() `arr[2] != "second"`;
if (arr[2] != 'third')
    err.do() `arr[2] != "third"`;
if (arr.count() != 3)
    err.do() `arr.count != 3`;

arr.delete(1);
if (arr[1] != 'third')
    err.do() `arr[1] != "third" after delete`;
if (arr[0] != 'first')
    err.do() `arr[0] != "first" after delete`;
if (arr.count() != 2)
    err.do() `arr.count() != 2 after delete`;

class IntWrapper {
    int val;

    oper init(int val) : val = val {}

    int cmp(Object other) {
        if (other.class.isSubclass(IntWrapper)) {
            return val - IntWrapper.unsafeCast(other).val;
        } else {
            return Object.cmp(other);
        }
    }

    void writeTo(Writer writer) {
        Formatter fmt = {writer};
        fmt `$val`; # `$(val / 1000000)`; # if you want to be able to debug
    }
}

tree := TreeMap();

# add a node
tree['val'] = 'test';
if (tree.get('val') != 'test')
    err.do() `lookup of "val" failed`;
if (tree.get('val') is null)
    err.do() `lookup of "val" failed`;
if (tree['val'] != 'test')
    err.do() `lookup of "val" failed`;
tree.delete('val');
if (tree.count() != 0)
    err.do() `count != 0`;
if (tree.get('val'))
    err.do() `tree still contains "val"`;

a := Array(1024);

int i;
while (i < 10000) {
    action := random() % 3;
    if (action < 2) {
        # insert a new random value
        
        # find an unused key
        v := IntWrapper(random());
        while (tree.get(v))
            v.val = random();

        out `$i: adding $v\n`;
        tree[v] = v;
        a.append(v);
    } else if (action == 2 && a.count()) {
        # delete key
        index := uint(random()) % a.count();
        out `$i: deleting a[$index]: $(a[index])\n`;
        tree.delete(a[index]);
        a.delete(index);
    }
    
    StringFormatter report = {};
    if (!tree.checkConstraints(report)) {
        out `$(report.createString())\n`;
        tree.dump();
        break;
    }
        
    ++i;
}

# fill a tree with the numbers from 0 to 99 and iterate over it.
i = 0;
tree = TreeMap();
while (i < 100) {
    v := IntWrapper(i);
    tree[v] = v;
    ++i;
}
StringFormatter report = {};
if (!tree.checkConstraints(report)) {
    out `$(report.createString())\n`;
}

ti := tree.iter();
i = 0;
while (ti.nx()) {
    actual := IntWrapper.cast(KeyVal.cast(ti.elem()).val).val;
    if (actual != i) {
        cout `at pos $i, got $actual\n`;
        err.do() `sucks`;
    }
    ++i;
}

cout `ok\n`;
